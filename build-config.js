/**
 * Build script to generate config files from environment variables
 * This script runs during the build process to inject environment variables
 * into the client-side configuration files.
 */

const fs = require('fs');
const path = require('path');

// Load environment variables
// In Vercel, process.env is available; locally, we load from .env file
// Try to load .env file if environment variables are not already set
try {
  const envFile = fs.readFileSync(path.join(__dirname, '.env'), 'utf8');
  envFile.split('\n').forEach(line => {
    const trimmedLine = line.trim();
    // Skip comments and empty lines
    if (!trimmedLine || trimmedLine.startsWith('#')) return;
    
    const [key, ...valueParts] = trimmedLine.split('=');
    if (key && valueParts.length > 0) {
      const value = valueParts.join('=').trim();
      // Remove quotes if present
      const cleanValue = value.replace(/^["']|["']$/g, '');
      // Only set if not already in process.env (environment variables take precedence)
      if (!process.env[key.trim()]) {
        process.env[key.trim()] = cleanValue;
      }
    }
  });
} catch (error) {
  // .env file not found - this is okay if environment variables are set in system/Vercel
  if (process.env.NODE_ENV !== 'production') {
    console.warn('Warning: .env file not found. Make sure environment variables are set.');
  }
}

// Get environment variables with fallback to empty strings
const SUPABASE_URL = process.env.VITE_SUPABASE_URL || process.env.SUPABASE_URL || '';
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY || process.env.SUPABASE_ANON_KEY || '';
const INTERCOM_ACCESS_TOKEN = process.env.VITE_INTERCOM_ACCESS_TOKEN || process.env.INTERCOM_ACCESS_TOKEN || '';
const INTERCOM_APP_ID = process.env.VITE_INTERCOM_APP_ID || process.env.INTERCOM_APP_ID || '';

// Validate required environment variables
if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('Error: SUPABASE_URL and SUPABASE_ANON_KEY are required');
  console.error('Please set them in your .env file or Vercel environment variables');
  process.exit(1);
}

// Warn if Intercom variables are missing (optional)
if (!INTERCOM_ACCESS_TOKEN || !INTERCOM_APP_ID) {
  console.warn('Warning: INTERCOM_ACCESS_TOKEN and/or INTERCOM_APP_ID are not set');
  console.warn('Intercom features may not work properly');
}

// Generate supabase-config.js
const supabaseConfig = `/**
 * Supabase Configuration and Client Setup
 * This file is auto-generated from environment variables
 * DO NOT EDIT MANUALLY - This file is generated by build-config.js
 */

// Supabase Configuration
const SUPABASE_URL = '${SUPABASE_URL}'
const SUPABASE_ANON_KEY = '${SUPABASE_ANON_KEY}'

// Initialize Supabase client
let supabaseClient = null

// Initialize Supabase when the library is loaded
function initializeSupabase() {
  if (typeof window.supabase !== 'undefined') {
    supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    
    // Make it globally available
    window.supabaseClient = supabaseClient
    
    console.log('Supabase client initialized successfully')
    return true
  }
  return false
}

// Wait for Supabase library to load
function waitForSupabase() {
  if (initializeSupabase()) {
    return
  }
  
  // Retry after a short delay
  setTimeout(waitForSupabase, 100)
}

// Start initialization
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', waitForSupabase)
} else {
  waitForSupabase()
}

// Export configuration for use in other files
window.SupabaseConfig = {
  url: SUPABASE_URL,
  anonKey: SUPABASE_ANON_KEY,
  getClient: () => supabaseClient
}

// Authentication helper functions
window.SupabaseAuth = {
  /**
   * Sign in with Google OAuth
   */
  async signInWithGoogle() {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    const { data, error } = await supabaseClient.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: window.location.origin
      }
    })
    
    if (error) {
      console.error('Google sign-in error:', error)
      throw error
    }
    
    return data
  },

  /**
   * Sign out the current user
   */
  async signOut() {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    const { error } = await supabaseClient.auth.signOut()
    
    if (error) {
      console.error('Sign-out error:', error)
      throw error
    }
    
    // Clear local storage
    localStorage.removeItem('userInfo')
    
    return true
  },

  /**
   * Get current user session
   */
  async getCurrentUser() {
    if (!supabaseClient) {
      return null
    }
    
    const { data: { user }, error } = await supabaseClient.auth.getUser()
    
    if (error) {
      // Only log non-session-missing errors to reduce console noise
      if (!error.message.includes('Auth session missing')) {
        console.error('Get user error:', error)
      }
      return null
    }
    
    return user
  },

  /**
   * Listen to auth state changes
   */
  onAuthStateChange(callback) {
    if (!supabaseClient) {
      return null
    }
    
    return supabaseClient.auth.onAuthStateChange(callback)
  }
}

// Database helper functions
window.SupabaseDB = {
  /**
   * Generic function to fetch data from any table
   */
  async fetch(tableName, options = {}) {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    let query = supabaseClient.from(tableName).select(options.select || '*')
    
    if (options.filter) {
      query = query.eq(options.filter.column, options.filter.value)
    }
    
    if (options.orderBy) {
      query = query.order(options.orderBy.column, { ascending: options.orderBy.ascending !== false })
    }
    
    if (options.limit) {
      query = query.limit(options.limit)
    }
    
    const { data, error } = await query
    
    if (error) {
      console.error(\`Error fetching from \${tableName}:\`, error)
      throw error
    }
    
    return data
  },

  /**
   * Generic function to insert data into any table
   */
  async insert(tableName, data) {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    const { data: result, error } = await supabaseClient
      .from(tableName)
      .insert(data)
      .select()
    
    if (error) {
      console.error(\`Error inserting into \${tableName}:\`, error)
      throw error
    }
    
    return result
  },

  /**
   * Generic function to update data in any table
   */
  async update(tableName, data, filter) {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    let query = supabaseClient.from(tableName).update(data)
    
    if (filter) {
      query = query.eq(filter.column, filter.value)
    }
    
    const { data: result, error } = await query.select()
    
    if (error) {
      console.error(\`Error updating \${tableName}:\`, error)
      throw error
    }
    
    return result
  },

  /**
   * Generic function to delete data from any table
   */
  async delete(tableName, filter) {
    if (!supabaseClient) {
      throw new Error('Supabase client not initialized')
    }
    
    if (!filter) {
      throw new Error('Filter is required for delete operations')
    }
    
    const { error } = await supabaseClient
      .from(tableName)
      .delete()
      .eq(filter.column, filter.value)
    
    if (error) {
      console.error(\`Error deleting from \${tableName}:\`, error)
      throw error
    }
    
    return true
  }
}

// User Management functions
window.SupabaseUsers = {
  /**
   * Get user by email from the users table
   */
  async getUserByEmail(email) {
    try {
      const users = await window.SupabaseDB.fetch('users', {
        filter: { column: 'email', value: email },
        limit: 1
      })
      return users.length > 0 ? users[0] : null
    } catch (error) {
      console.error('Error fetching user by email:', error)
      return null
    }
  },

  /**
   * Get user by ID from the users table (now uses email as primary key)
   */
  async getUserById(id) {
    try {
      const users = await window.SupabaseDB.fetch('users', {
        filter: { column: 'email', value: id },
        limit: 1
      })
      return users.length > 0 ? users[0] : null
    } catch (error) {
      console.error('Error fetching user by ID:', error)
      return null
    }
  },

  /**
   * Get all users with optional filtering
   */
  async getAllUsers(options = {}) {
    try {
      return await window.SupabaseDB.fetch('users', options)
    } catch (error) {
      console.error('Error fetching all users:', error)
      return []
    }
  },

  /**
   * Update user information
   */
  async updateUser(userEmail, userData) {
    try {
      return await window.SupabaseDB.update('users', userData, { column: 'email', value: userEmail })
    } catch (error) {
      console.error('Error updating user:', error)
      throw error
    }
  },

  /**
   * Create a new user
   */
  async createUser(userData) {
    try {
      return await window.SupabaseDB.insert('users', userData)
    } catch (error) {
      console.error('Error creating user:', error)
      throw error
    }
  },

  /**
   * Get users by role
   */
  async getUsersByRole(role) {
    try {
      return await window.SupabaseDB.fetch('users', {
        filter: { column: 'role', value: role },
        orderBy: { column: 'name', ascending: true }
      })
    } catch (error) {
      console.error('Error fetching users by role:', error)
      return []
    }
  },

  /**
   * Get users by department
   */
  async getUsersByDepartment(department) {
    try {
      return await window.SupabaseDB.fetch('users', {
        filter: { column: 'department', value: department },
        orderBy: { column: 'name', ascending: true }
      })
    } catch (error) {
      console.error('Error fetching users by department:', error)
      return []
    }
  },

  /**
   * Update user's last login
   */
  async updateLastLogin(userId) {
    try {
      const currentCount = await this.incrementLoginCount(userId)
      return await window.SupabaseDB.update('users', {
        last_login: new Date().toISOString(),
        login_count: currentCount.toString()
      }, { column: 'email', value: userId })
    } catch (error) {
      console.error('Error updating last login:', error)
      throw error
    }
  },

  /**
   * Increment user's login count
   */
  async incrementLoginCount(userId) {
    try {
      const user = await this.getUserByEmail(userId)
      const currentCount = parseInt(user?.login_count || '0')
      return (currentCount + 1).toString()
    } catch (error) {
      console.error('Error incrementing login count:', error)
      return '1'
    }
  }
}
`;

// Generate intercom-config.js
// NOTE: accessToken is NOT included here - it should only be used server-side
// (e.g., in Supabase Edge Functions). Only appId is needed client-side for UI links.
const intercomConfig = `// Intercom API Configuration
// This file is auto-generated from environment variables
// DO NOT EDIT MANUALLY - This file is generated by build-config.js
// NOTE: accessToken is not included here for security - it's only used server-side
window.intercomConfig = {
    // API Base URL
    apiBaseUrl: 'https://api.intercom.io',
    
    // App ID (safe to expose - used for UI links)
    appId: '${INTERCOM_APP_ID}'
};
`;

// Write config files
fs.writeFileSync(path.join(__dirname, 'supabase-config.js'), supabaseConfig);
fs.writeFileSync(path.join(__dirname, 'intercom-config.js'), intercomConfig);

console.log('âœ“ Configuration files generated successfully');
console.log('  - supabase-config.js');
console.log('  - intercom-config.js');

