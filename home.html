<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Home | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet"></noscript>
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = {
    theme: {
      extend: {
        colors: {
          primary: '#1a733e',
          'primary-dark': '#0d5e3a',
          'dark-forest': '#032816',
          'success': '#10b981',
          'warning': '#f59e0b',
          'error': '#ef4444',
        },
        fontFamily: {
          sans: ['Poppins', 'sans-serif'],
        },
      },
    },
  }
</script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="env-config.js"></script>
<script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="confirmation-dialog.js" defer></script>
    <script src="load-sidebar.js" defer></script>
    <script src="search.js" defer></script>
    <script src="form-validation.js" defer></script>
    <script src="keyboard-shortcuts.js" defer></script>
<style>
  .main-content {
    background-color: #f8f7f2;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
  
  /* Override sidebar.css centering for home page */
  .main-content > * {
    width: 100%;
  }

  /* Date Range Picker and Filter Styles */
  .header-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 1rem;
  }

  .action-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.5rem 0.75rem;
    background-color: white;
    color: #374151;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Poppins', sans-serif;
  }

  .action-btn:hover {
    background-color: #f9fafb;
    border-color: #1a733e;
  }

  .action-btn.active {
    background-color: #1a733e;
    color: white;
    border-color: #1a733e;
  }

  .action-btn svg {
    width: 0.875rem;
    height: 0.875rem;
  }

  /* Filter Panel */
  .filter-panel {
    display: none;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    padding: 1rem;
    margin-bottom: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.75rem;
  }

  .filter-panel.active {
    display: grid;
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
  }

  .filter-label {
    font-size: 0.625rem;
    font-weight: 600;
    color: #6b7280;
  }

  .filter-input, .filter-select {
    padding: 0.375rem 0.5rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-family: 'Poppins', sans-serif;
    background-color: white;
    color: #374151;
  }

  .filter-input:focus, .filter-select:focus {
    outline: none;
    border-color: #1a733e;
  }

  /* Date Range Picker */
  .date-picker-dropdown {
    position: relative;
    display: inline-block;
  }

  .date-dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 0.375rem;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    padding: 0.75rem;
    z-index: 1000;
    min-width: 250px;
  }

  .date-dropdown-menu.active {
    display: block;
  }
</style>
</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
  <!-- Header Bar -->
  <header class="sticky top-0 z-40">
    <div class="flex items-center justify-between px-4 py-2">
      <!-- Left: Logo + Create Button -->
      <div class="flex items-center gap-3">
        <div class="flex items-center gap-2">
          <svg class="w-4 h-4 text-primary" viewBox="0 -960 960 960" fill="currentColor">
            <path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm491-80h69v-69l-69 69Zm-457 0h73l120-120h85L452-200h64l120-120h85L541-200h65l120-120h34v-440H200v509l69-69h85L434-200Zm72-200-56-56 177-177 80 80 147-147 56 56-203 204-80-80-121 120Z"/>
          </svg>
          <span class="text-xs font-semibold text-gray-800 hidden sm:inline">NEXT QMS</span>
        </div>
        <button id="createAuditBtn" onclick="window.location.href='create-audit.html'" class="flex items-center gap-1.5 px-3 py-1.5 bg-primary text-white rounded text-xs font-medium hover:bg-primary-dark transition-colors">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
          Add
        </button>
      </div>

      <!-- Right: Action Icons -->
      <div class="flex items-center gap-2">
        <button onclick="window.location.href='search.html'" class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
          </svg>
        </button>
        <div id="notificationBtn" class="relative group">
          <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors relative">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
            </svg>
            <span id="notificationBadge" class="absolute top-0.5 right-0.5 w-1.5 h-1.5 bg-error rounded-full"></span>
          </button>
          
          <!-- Notifications Modal - Appears on hover -->
          <div id="notificationsModal" class="absolute top-full right-0 mt-2 bg-white rounded-lg shadow-xl w-80 max-h-[calc(100vh-5rem)] flex flex-col opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50" onmouseleave="hideNotifications()">
            <!-- Modal Header -->
            <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
              <h3 class="text-sm font-semibold text-gray-900">Notifications</h3>
              <button onclick="hideNotifications()" class="text-gray-400 hover:text-gray-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
            
            <!-- Notifications List -->
            <div id="notificationsList" class="flex-1 overflow-y-auto divide-y divide-gray-200">
              <div class="px-4 py-8 text-center text-gray-500 text-xs">
                <div class="animate-pulse">Loading notifications...</div>
              </div>
            </div>
          </div>
        </div>
        <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
          </svg>
        </button>
        <button class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
          </svg>
        </button>
        <div id="userAvatar" class="w-7 h-7 rounded-full bg-primary flex items-center justify-center text-white text-xs font-medium cursor-pointer hover:bg-primary-dark transition-colors">
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20z"/>
          </svg>
        </div>
      </div>
    </div>
  </header>

  <!-- Main Dashboard Content -->
  <div class="px-4 py-4 max-w-7xl mx-auto w-full">
    <h1 class="text-xl font-bold text-gray-900 mb-4">Home</h1>

    <!-- Action Buttons -->
    <div class="header-actions">
      <!-- Week Navigation -->
      <div style="display: flex; align-items: center; gap: 0.5625rem;">
        <button class="action-btn" id="prevWeekBtn" style="padding: 0.5rem 0.5625rem;" title="Previous Week">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
          </svg>
        </button>
        <div class="action-btn" id="weekDisplay" style="padding: 0.5rem 0.75rem; cursor: default; background-color: #1a733e; color: white; border-color: #1a733e;">
          <span id="weekText">Week -</span>
        </div>
        <button class="action-btn" id="nextWeekBtn" style="padding: 0.5rem 0.5625rem;" title="Next Week">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
          </svg>
        </button>
      </div>
      <div class="date-picker-dropdown">
        <button class="action-btn" id="dateBtn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
          </svg>
          <span id="dateBtnText">Date Range</span>
          <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="date-dropdown-menu" id="dateDropdown">
          <div class="filter-group">
            <label class="filter-label">Start Date</label>
            <input type="date" class="filter-input" id="startDate">
          </div>
          <div class="filter-group">
            <label class="filter-label">End Date</label>
            <input type="date" class="filter-input" id="endDate">
          </div>
          <div style="display: flex; gap: 0.375rem; margin-top: 0.375rem;">
            <button class="action-btn" style="flex: 1;" onclick="applyDateFilter()">Apply</button>
            <button class="action-btn" style="flex: 1;" onclick="clearDateFilter()">Clear</button>
          </div>
        </div>
      </div>
      <button class="action-btn" id="filterBtn">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
        </svg>
        <span>Filter</span>
      </button>
    </div>

    <!-- Filter Panel -->
    <div class="filter-panel" id="filterPanel">
      <div class="filter-group">
        <label class="filter-label">Channel</label>
        <select class="filter-select" id="filterChannel">
          <option value="">All Channels</option>
        </select>
      </div>
      <div class="filter-group">
        <label class="filter-label">Status</label>
        <select class="filter-select" id="filterStatus">
          <option value="">All Statuses</option>
          <option value="pending">Pending</option>
          <option value="in_progress">In Progress</option>
          <option value="completed">Completed</option>
        </select>
      </div>
      <div class="filter-group" id="filterAgentGroup" style="display: none;">
        <label class="filter-label">Agent</label>
        <select class="filter-select" id="filterAgent">
          <option value="">All Agents</option>
        </select>
      </div>
      <div class="filter-group" style="align-self: flex-end;">
        <button class="action-btn" onclick="applyFilters()" style="margin-top: 1.125rem;">Apply Filters</button>
      </div>
    </div>

    <!-- Stats Cards -->
    <div class="flex flex-nowrap gap-3 mb-4 overflow-x-auto">
      <!-- Audits Conducted Card -->
      <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Audits Conducted</div>
        <div class="text-3xl font-bold text-gray-900 mb-2" id="statsAuditsConductedCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <!-- Progress bar showing remaining audits -->
        <div class="mt-2">
          <div class="flex items-center justify-between mb-1">
            <span class="text-[10px] font-medium text-gray-600" id="statsRemainingText">- remaining</span>
          </div>
          <div class="w-full bg-gray-200 rounded-full h-1.5">
            <div class="bg-success h-1.5 rounded-full transition-all duration-300" id="statsRemainingProgress" style="width: 0%"></div>
          </div>
        </div>
      </div>

      <!-- Average Quality Score Card -->
      <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-success/10 flex items-center justify-center group-hover:bg-success/20 transition-colors">
            <svg class="w-5 h-5 text-success" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Average Quality Score</div>
        <div class="flex items-start gap-2 mb-1">
          <div class="text-3xl font-bold text-gray-900" id="statsAvgQualityScore">
            <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
          </div>
          <div class="flex flex-col gap-1">
            <div class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[8px] font-semibold bg-green-100 text-green-800" id="statsPassingCount">
              <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
              </svg>
              <span class="inline-block h-3 w-4 bg-gray-200 rounded animate-pulse"></span>
              <span>Passed</span>
            </div>
            <div class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[8px] font-semibold bg-red-100 text-red-800" id="statsNotPassingCount">
              <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
              <span class="inline-block h-3 w-4 bg-gray-200 rounded animate-pulse"></span>
              <span>Not Passed</span>
            </div>
          </div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsAvgScoreSubtitle">
          <div class="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Remaining Card -->
      <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-warning/10 flex items-center justify-center group-hover:bg-warning/20 transition-colors">
            <svg class="w-5 h-5 text-warning" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Remaining</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsRemainingCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- In Progress Card -->
      <div id="inProgressCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">In Progress</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsInProgressCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsDaysRemaining">
          <div class="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <!-- Reversal Card -->
      <div class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-error/10 flex items-center justify-center group-hover:bg-error/20 transition-colors">
            <svg class="w-5 h-5 text-error" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Reversal</div>
        <div class="text-3xl font-bold text-gray-900 mb-2" id="statsReversalTotalCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="flex items-center gap-3 text-xs flex-wrap">
          <div class="flex items-center gap-1">
            <span class="text-gray-600">Active:</span>
            <span class="font-semibold text-warning" id="statsReversalActiveCount">
              <span class="inline-block h-4 w-6 bg-gray-200 rounded animate-pulse"></span>
            </span>
          </div>
          <div class="flex items-center gap-1">
            <span class="text-gray-600">Resolved:</span>
            <span class="font-semibold text-success" id="statsReversalResolvedCount">
              <span class="inline-block h-4 w-6 bg-gray-200 rounded animate-pulse"></span>
            </span>
          </div>
        </div>
      </div>

      <!-- Requires Acknowledgment Card (Agents Only) -->
      <div id="requiresAcknowledgmentCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0" style="display: none;">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Requires Acknowledgment</div>
        <div class="text-3xl font-bold text-gray-900 mb-1" id="statsRequiresAcknowledgmentCount">
          <div class="h-8 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1">reports pending</div>
      </div>

      <!-- Avg Duration Card -->
      <div id="avgDurationCard" class="bg-white rounded-xl border border-gray-200 p-4 shadow-sm hover:shadow-md transition-shadow group flex-1 min-w-0">
        <div class="flex items-center justify-between mb-2">
          <div class="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center group-hover:bg-primary/20 transition-colors">
            <svg class="w-5 h-5 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </div>
        </div>
        <div class="text-[10px] font-semibold text-gray-500 uppercase tracking-wide mb-1">Avg Duration</div>
        <div class="text-2xl font-bold text-gray-900 mb-1" id="statsAvgDuration">
          <div class="h-7 w-16 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div class="text-xs font-medium text-gray-600 mt-1" id="statsAvgDurationSubtitle">per audit</div>
      </div>
    </div>

    <!-- Two Column Layout -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
      <!-- Left Column: Updates Feed -->
      <div class="lg:col-span-1">
        <div class="bg-white rounded border border-gray-200">
          <div class="px-4 py-3 border-b border-gray-200">
            <h2 id="updatesSectionTitle" class="text-sm font-semibold text-gray-900 flex items-center gap-2">
              <span>Updates to your audits</span>
              <span id="reversalUpdatesCount" class="bg-warning text-white px-2 py-0.5 rounded text-xs font-semibold" style="display: none;">0</span>
            </h2>
          </div>
          <div id="updatesFeed" class="divide-y divide-gray-200 max-h-[calc(100vh-300px)] overflow-y-auto">
            <div class="px-4 py-3 space-y-3">
              <div class="flex items-start gap-3">
                <div class="w-8 h-8 bg-gray-200 rounded-full animate-pulse flex-shrink-0"></div>
                <div class="flex-1 space-y-2">
                  <div class="h-4 w-3/4 bg-gray-200 rounded animate-pulse"></div>
                  <div class="h-3 w-1/2 bg-gray-200 rounded animate-pulse"></div>
                </div>
              </div>
              <div class="flex items-start gap-3">
                <div class="w-8 h-8 bg-gray-200 rounded-full animate-pulse flex-shrink-0"></div>
                <div class="flex-1 space-y-2">
                  <div class="h-4 w-3/4 bg-gray-200 rounded animate-pulse"></div>
                  <div class="h-3 w-1/2 bg-gray-200 rounded animate-pulse"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Column: Assigned Audits -->
      <div class="lg:col-span-2">
        <div class="bg-white rounded border border-gray-200">
          <div class="px-4 py-3 border-b border-gray-200 flex items-center justify-between">
            <h2 class="text-sm font-semibold text-gray-900 flex items-center gap-2">
              <span id="auditsSectionTitle">My Audits</span>
              <span id="pendingCount" class="bg-primary text-white px-2 py-0.5 rounded text-xs font-semibold">0</span>
            </h2>
            <div class="flex items-center gap-2">
              <button id="viewAllBtn" onclick="window.location.href='expert-audits.html'" class="px-3 py-1.5 bg-primary text-white text-xs font-semibold rounded hover:bg-primary-dark transition-colors" style="display: none;">
                View All
              </button>
              <button id="sortBtn" onclick="toggleSortMenu()" class="p-1.5 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12"/>
                </svg>
              </button>
              <div id="sortMenu" class="hidden absolute mt-2 bg-white border border-gray-200 rounded shadow-lg z-10">
                <select id="auditSortBy" onchange="sortAssignedAudits()" class="w-full px-3 py-2 text-xs border-0 focus:ring-0">
                  <option value="name_asc">Name (A-Z)</option>
                  <option value="name_desc">Name (Z-A)</option>
                  <option value="status_asc" id="statusAscOption">Status</option>
                  <option value="status_desc" id="statusDescOption">Status</option>
                  <option value="date_desc" selected>Date (Newest)</option>
                  <option value="date_asc">Date (Oldest)</option>
                </select>
              </div>
            </div>
          </div>
          <div id="assignedAuditsList" class="divide-y divide-gray-200 max-h-[calc(100vh-300px)] overflow-y-auto">
            <div class="px-4 py-3 space-y-3">
              <div class="flex items-center justify-between p-3 border border-gray-200 rounded">
                <div class="flex-1 space-y-2">
                  <div class="h-4 w-1/3 bg-gray-200 rounded animate-pulse"></div>
                  <div class="h-3 w-1/4 bg-gray-200 rounded animate-pulse"></div>
                </div>
                <div class="h-6 w-20 bg-gray-200 rounded animate-pulse"></div>
              </div>
              <div class="flex items-center justify-between p-3 border border-gray-200 rounded">
                <div class="flex-1 space-y-2">
                  <div class="h-4 w-1/3 bg-gray-200 rounded animate-pulse"></div>
                  <div class="h-3 w-1/4 bg-gray-200 rounded animate-pulse"></div>
                </div>
                <div class="h-6 w-20 bg-gray-200 rounded animate-pulse"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

</main>

<script>
// Dashboard State
let currentUserEmail = '';
let currentUserRole = '';
let isAgent = false;
let allUsers = [];
let allAssignments = [];
let assignedAudits = [];
let sortBy = 'date_desc'; // Default will be updated based on user role
let notifications = [];
let unreadNotificationCount = 0;

// Date Filter State
let dateFilter = { start: null, end: null };
let currentFilters = { channel: '', status: '', agent: '' };
let currentWeek = null; // Current week number (1-52)
let currentWeekYear = null; // Year for the current week
let useWeekFilter = true; // Whether to use week filter (default) or date range filter

// Helper function to get week number (1-52)
function getWeekNumber(date = new Date()) {
  // Get the first day of the year
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  
  // Calculate the Monday of week 1 (the Monday of the week containing Jan 1)
  // If Jan 1 is Sunday (getDay() === 0), Monday is 6 days before (previous Monday)
  // Otherwise, Monday is (getDay() - 1) days before Jan 1
  const dayOfWeek = startOfYear.getDay();
  const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const mondayOfWeek1 = new Date(startOfYear);
  mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
  mondayOfWeek1.setHours(0, 0, 0, 0);
  
  // Calculate the Monday of the week containing the given date
  const dateDay = date.getDay();
  const dateDaysToMonday = dateDay === 0 ? -6 : 1 - dateDay;
  const mondayOfDateWeek = new Date(date);
  mondayOfDateWeek.setDate(date.getDate() + dateDaysToMonday);
  mondayOfDateWeek.setHours(0, 0, 0, 0);
  
  // Calculate the number of days from Monday of week 1 to Monday of date's week
  const daysSinceWeek1 = Math.floor((mondayOfDateWeek - mondayOfWeek1) / (24 * 60 * 60 * 1000));
  
  // Calculate the week number (starting from 1)
  const weekNumber = Math.floor(daysSinceWeek1 / 7) + 1;
  
  return weekNumber;
}

// Helper function to get week dates (Monday to Sunday)
function getWeekDates(weekNumber, year) {
  // Get the first day of the year
  const startOfYear = new Date(year, 0, 1);
  
  // Calculate the Monday of week 1 (the Monday of the week containing Jan 1)
  const dayOfWeek = startOfYear.getDay();
  const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const mondayOfWeek1 = new Date(startOfYear);
  mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
  
  // Calculate the Monday of the desired week
  const weekStart = new Date(mondayOfWeek1);
  weekStart.setDate(mondayOfWeek1.getDate() + (weekNumber - 1) * 7);
  weekStart.setHours(0, 0, 0, 0);
  
  // Calculate the last day of the week (Sunday)
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekStart.getDate() + 6);
  weekEnd.setHours(23, 59, 59, 999);
  
  return { start: weekStart, end: weekEnd };
}

// Initialize week filter
function initializeWeekFilter() {
  const today = new Date();
  currentWeek = getWeekNumber(today);
  currentWeekYear = today.getFullYear();
  updateWeekDisplay();
}

// Update week display
function updateWeekDisplay() {
  const weekTextEl = document.getElementById('weekText');
  const prevWeekBtn = document.getElementById('prevWeekBtn');
  const nextWeekBtn = document.getElementById('nextWeekBtn');
  const weekDisplay = document.getElementById('weekDisplay');
  
  if (weekTextEl) {
    if (useWeekFilter && currentWeek !== null) {
      weekTextEl.textContent = `Week ${currentWeek}`;
    } else {
      weekTextEl.textContent = '-';
    }
  }
  
  // Disable/enable week navigation buttons based on date range filter
  if (prevWeekBtn) {
    if (useWeekFilter) {
      prevWeekBtn.disabled = false;
      prevWeekBtn.style.opacity = '1';
      prevWeekBtn.style.cursor = 'pointer';
    } else {
      prevWeekBtn.disabled = true;
      prevWeekBtn.style.opacity = '0.5';
      prevWeekBtn.style.cursor = 'not-allowed';
    }
  }
  
  if (nextWeekBtn) {
    if (useWeekFilter) {
      nextWeekBtn.disabled = false;
      nextWeekBtn.style.opacity = '1';
      nextWeekBtn.style.cursor = 'pointer';
    } else {
      nextWeekBtn.disabled = true;
      nextWeekBtn.style.opacity = '0.5';
      nextWeekBtn.style.cursor = 'not-allowed';
    }
  }
  
  // Update week display styling
  if (weekDisplay) {
    if (useWeekFilter) {
      weekDisplay.style.backgroundColor = '#1a733e';
      weekDisplay.style.color = 'white';
      weekDisplay.style.borderColor = '#1a733e';
    } else {
      weekDisplay.style.backgroundColor = '#f3f4f6';
      weekDisplay.style.color = '#6b7280';
      weekDisplay.style.borderColor = '#e5e7eb';
    }
  }
}

// Navigate week
function navigateWeek(direction) {
  currentWeek += direction;
  
  // Handle week overflow/underflow
  if (currentWeek > 52) {
    currentWeek = 1;
    currentWeekYear += 1;
  } else if (currentWeek < 1) {
    currentWeek = 52;
    currentWeekYear -= 1;
  }
  
  updateWeekDisplay();
  useWeekFilter = true; // Ensure week filter is active
  dateFilter.start = null;
  dateFilter.end = null;
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  updateDateButtonText();
  
  // Reload data with week filter
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]);
}

// Initialize date filter (now uses week filter by default)
function initializeDateFilter() {
  initializeWeekFilter();
  updateDateButtonText();
}

function formatDateForInput(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function updateDateButtonText() {
  const dateBtnText = document.getElementById('dateBtnText');
  if (!dateBtnText) return;
  
  if (dateFilter.start && dateFilter.end) {
    const start = new Date(dateFilter.start);
    const end = new Date(dateFilter.end);
    const startStr = start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const endStr = end.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    dateBtnText.textContent = `${startStr} - ${endStr}`;
  } else {
    dateBtnText.textContent = 'Date Range';
  }
}

// Get current period dates (week or date range)
function getCurrentPeriodDates() {
  if (dateFilter.start || dateFilter.end) {
    // Using date range filter
    return {
      start: dateFilter.start ? new Date(dateFilter.start) : new Date(0),
      end: dateFilter.end ? new Date(dateFilter.end) : new Date()
    };
  } else if (useWeekFilter && currentWeek !== null) {
    // Using week filter
    return getWeekDates(currentWeek, currentWeekYear);
  } else {
    // Default to current week
    const today = new Date();
    return getWeekDates(getWeekNumber(today), today.getFullYear());
  }
}

// Apply date filter
function applyDateFilter() {
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  
  if (startDateInput && startDateInput.value) {
    const startDate = new Date(startDateInput.value);
    startDate.setHours(0, 0, 0, 0);
    dateFilter.start = startDate;
  } else {
    dateFilter.start = null;
  }
  
  if (endDateInput && endDateInput.value) {
    const endDate = new Date(endDateInput.value);
    endDate.setHours(23, 59, 59, 999);
    dateFilter.end = endDate;
  } else {
    dateFilter.end = null;
  }
  
  // Update button text
  if (dateFilter.start || dateFilter.end) {
    const start = dateFilter.start ? new Date(dateFilter.start).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'Start';
    const end = dateFilter.end ? new Date(dateFilter.end).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'End';
    const dateBtnText = document.getElementById('dateBtnText');
    if (dateBtnText) {
      dateBtnText.textContent = `${start} - ${end}`;
    }
    useWeekFilter = false; // Date range overrides week filter
    updateWeekDisplay(); // Update week display to show "-"
  } else {
    updateDateButtonText();
    useWeekFilter = true; // Clear date range, go back to week filter
    updateWeekDisplay(); // Update week display to show week number
  }
  
  document.getElementById('dateDropdown').classList.remove('active');
  
  // Reload data with filters
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]);
}

// Clear date filter
function clearDateFilter() {
  dateFilter.start = null;
  dateFilter.end = null;
  const startDateInput = document.getElementById('startDate');
  const endDateInput = document.getElementById('endDate');
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  updateDateButtonText();
  document.getElementById('dateDropdown').classList.remove('active');
  useWeekFilter = true; // Go back to week filter
  updateWeekDisplay(); // Update week display to show week number
  
  // Reload data with week filter
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]);
}

// Apply filters
function applyFilters() {
  const channelSelect = document.getElementById('filterChannel');
  const statusSelect = document.getElementById('filterStatus');
  const agentSelect = document.getElementById('filterAgent');
  
  currentFilters.channel = channelSelect ? channelSelect.value : '';
  currentFilters.status = statusSelect ? statusSelect.value : '';
  currentFilters.agent = agentSelect ? agentSelect.value : '';
  
  // Reload data with filters
  Promise.all([
    loadRecentUpdates(),
    updateYourStats(),
    loadAssignedAudits(),
    loadNotifications()
  ]);
}

// Cache helper functions - unlimited cache with background refresh
function getCacheKey(prefix, userEmail, period = null) {
  const periodKey = period ? `${period.start}_${period.end}` : 'default';
  return `homepage_cache_${prefix}_${userEmail}_${periodKey}`;
}

function getCachedData(cacheKey) {
  try {
    const cached = localStorage.getItem(cacheKey);
    if (!cached) return null;
    
    const { data, timestamp } = JSON.parse(cached);
    return data;
  } catch (e) {
    console.warn('Error reading cache:', e);
    return null;
  }
}

function setCachedData(cacheKey, data) {
  try {
    localStorage.setItem(cacheKey, JSON.stringify({
      data,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.warn('Error writing cache:', e);
    // If storage is full, clear old cache entries
    if (e.name === 'QuotaExceededError') {
      clearOldCache();
      // Try once more
      try {
        localStorage.setItem(cacheKey, JSON.stringify({
          data,
          timestamp: Date.now()
        }));
      } catch (e2) {
        console.error('Failed to cache after cleanup:', e2);
      }
    }
  }
}

function clearOldCache() {
  try {
    const keys = Object.keys(localStorage);
    const cacheKeys = keys.filter(k => k.startsWith('homepage_cache_'));
    
    // Keep only the most recent cache for each prefix/user combination
    const cacheGroups = {};
    cacheKeys.forEach(key => {
      const parts = key.split('_');
      if (parts.length >= 4) {
        const prefix = parts[2];
        const userEmail = parts[3];
        const groupKey = `${prefix}_${userEmail}`;
        if (!cacheGroups[groupKey]) {
          cacheGroups[groupKey] = [];
        }
        cacheGroups[groupKey].push(key);
      }
    });
    
    // For each group, keep only the most recent entry
    Object.values(cacheGroups).forEach(group => {
      if (group.length > 1) {
        // Sort by timestamp and keep only the newest
        const withTimestamps = group.map(key => {
          try {
            const cached = localStorage.getItem(key);
            if (cached) {
              const { timestamp } = JSON.parse(cached);
              return { key, timestamp };
            }
          } catch (e) {
            return { key, timestamp: 0 };
          }
        }).sort((a, b) => b.timestamp - a.timestamp);
        
        // Remove all but the newest
        withTimestamps.slice(1).forEach(({ key }) => {
          localStorage.removeItem(key);
        });
      }
    });
  } catch (e) {
    console.warn('Error clearing old cache:', e);
  }
}

function invalidateHomepageCache(userEmail = null) {
  try {
    const keys = Object.keys(localStorage);
    const cacheKeys = keys.filter(k => k.startsWith('homepage_cache_'));
    
    if (userEmail) {
      // Invalidate only for specific user
      cacheKeys.forEach(key => {
        if (key.includes(userEmail)) {
          localStorage.removeItem(key);
        }
      });
    } else {
      // Invalidate all homepage cache
      cacheKeys.forEach(key => localStorage.removeItem(key));
    }
  } catch (e) {
    console.warn('Error invalidating cache:', e);
  }
}

// Populate filter options
async function populateFilters() {
  try {
    const cacheKey = getCacheKey('filters', currentUserEmail, null);
    
    // Check cache first and render immediately
    const cachedFilters = getCachedData(cacheKey);
    if (cachedFilters) {
      console.log('Rendering cached filters immediately');
      renderFiltersFromData(cachedFilters);
    }
    
    // Always fetch fresh data in background
    fetchAndCacheFilters(cacheKey);
  } catch (error) {
    console.error('Error populating filters:', error);
  }
}

async function fetchAndCacheFilters(cacheKey) {
  try {
    // Load all assignments for filter population (without filters)
    let allAssignmentsForFilters = [];
    
    if (isAgent) {
      // For agents, load all completed audits to get channels
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        for (const scorecard of scorecards) {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('channel, employee_email')
              .eq('employee_email', currentUserEmail);
            
            if (!error && audits) {
              allAssignmentsForFilters = allAssignmentsForFilters.concat(audits);
            }
          } catch (err) {
            console.warn(`Error loading audits for filters from ${scorecard.table_name}:`, err);
          }
        }
      }
    } else {
      // For auditors, load all assignments from audit tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const assignmentPromises = scorecards.map(async (scorecard) => {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('channel, employee_email, audit_status')
              .eq('auditor_email', currentUserEmail)
              .in('audit_status', ['pending', 'in_progress', 'completed']);
            
            if (!error && audits) {
              return audits;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const assignmentResults = await Promise.all(assignmentPromises);
        allAssignmentsForFilters = assignmentResults.flat();
      }
    }
    
    // Populate channels
    const channels = [...new Set(allAssignmentsForFilters.map(a => a.channel).filter(Boolean))].sort();
    const agents = !isAgent ? [...new Set(allAssignmentsForFilters.map(a => a.employee_email).filter(Boolean))].sort() : [];
    
    // Cache the fresh data
    const filtersData = { channels, agents };
    setCachedData(cacheKey, filtersData);
    
    // Update UI with fresh data
    console.log('Updating UI with fresh filters');
    renderFiltersFromData(filtersData);
  } catch (error) {
    console.error('Error populating filters:', error);
  }
}

function renderFiltersFromData(filtersData) {
  const { channels, agents } = filtersData;
  
  // Populate channels
  const channelSelect = document.getElementById('filterChannel');
  if (channelSelect) {
    const existingValue = channelSelect.value;
    channelSelect.innerHTML = '<option value="">All Channels</option>';
    channels.forEach(channel => {
      const option = document.createElement('option');
      option.value = channel;
      option.textContent = channel;
      channelSelect.appendChild(option);
    });
    if (existingValue) channelSelect.value = existingValue;
  }

  // Populate agents (only for auditors)
  if (!isAgent) {
    const agentSelect = document.getElementById('filterAgent');
    const agentGroup = document.getElementById('filterAgentGroup');
    if (agentSelect && agentGroup) {
      const existingValue = agentSelect.value;
      agentSelect.innerHTML = '<option value="">All Agents</option>';
      agents.forEach(agent => {
        const option = document.createElement('option');
        option.value = agent;
        option.textContent = formatAgentName(agent);
        agentSelect.appendChild(option);
      });
      if (existingValue) agentSelect.value = existingValue;
      agentGroup.style.display = 'flex';
    }
  }
}

function formatAgentName(email) {
  if (!email || email === 'Unknown') return 'Unknown';
  return email.split('@')[0].replace(/\./g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Helper function to check if date is within filter range
function isDateInRange(date, filterStart, filterEnd) {
  // If no filters, check against current period (week or date range)
  if (!filterStart && !filterEnd) {
    const period = getCurrentPeriodDates();
    filterStart = period.start;
    filterEnd = period.end;
  }
  
  if (!filterStart && !filterEnd) return true;
  const checkDate = new Date(date);
  checkDate.setHours(0, 0, 0, 0);
  
  if (filterStart) {
    const start = new Date(filterStart);
    start.setHours(0, 0, 0, 0);
    if (checkDate < start) return false;
  }
  
  if (filterEnd) {
    const end = new Date(filterEnd);
    end.setHours(23, 59, 59, 999);
    if (checkDate > end) return false;
  }
  
  return true;
}

// Initialize Dashboard
document.addEventListener('DOMContentLoaded', async function() {
  await initializeDashboard();
});

// Wait for Supabase with better strategy
async function waitForSupabase(maxWait = 2000) {
  if (window.supabaseClient) return true;
  
  const startTime = Date.now();
  return new Promise((resolve) => {
    const checkInterval = setInterval(() => {
      if (window.supabaseClient) {
        clearInterval(checkInterval);
        resolve(true);
      } else if (Date.now() - startTime > maxWait) {
        clearInterval(checkInterval);
        resolve(false);
      }
    }, 50); // Check every 50ms instead of 100ms
  });
}

async function initializeDashboard() {
  try {
    // Get current user immediately (from cache) - no need to wait
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    currentUserEmail = (userInfo.email || '').toLowerCase().trim();
    currentUserRole = userInfo.role || '';
    isAgent = currentUserRole === 'Employee';

    if (!currentUserEmail) {
      console.error('No user logged in');
      return;
    }

    // Initialize UI immediately - no waiting
    initializeDateFilter();
    setupEventListeners();
    updateUserAvatar(userInfo);

    // Update section titles for agents and hide create audit button
    if (isAgent) {
      const auditsTitle = document.getElementById('auditsSectionTitle');
      if (auditsTitle) auditsTitle.textContent = 'My Audits';
      const updatesTitle = document.getElementById('updatesSectionTitle');
      if (updatesTitle) updatesTitle.textContent = 'Updates to my audits';
      const createAuditBtn = document.getElementById('createAuditBtn');
      if (createAuditBtn) createAuditBtn.style.display = 'none';
      const inProgressCard = document.getElementById('inProgressCard');
      if (inProgressCard) inProgressCard.style.display = 'none';
      const avgDurationCard = document.getElementById('avgDurationCard');
      if (avgDurationCard) avgDurationCard.style.display = 'none';
      // Show acknowledgment card for agents
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'block';
    } else {
      // Hide acknowledgment card for non-agents
      const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
      if (requiresAcknowledgmentCard) requiresAcknowledgmentCard.style.display = 'none';
      const auditsTitle = document.getElementById('auditsSectionTitle');
      if (auditsTitle) auditsTitle.textContent = 'My Assigned Audits';
      const viewAllBtn = document.getElementById('viewAllBtn');
      if (viewAllBtn) viewAllBtn.style.display = 'block';
      const statusAscOption = document.getElementById('statusAscOption');
      const statusDescOption = document.getElementById('statusDescOption');
      if (statusAscOption) statusAscOption.textContent = 'Status (Pending  In Progress)';
      if (statusDescOption) statusDescOption.textContent = 'Status (In Progress  Pending)';
      sortBy = 'status_desc';
      const auditSortBy = document.getElementById('auditSortBy');
      if (auditSortBy) auditSortBy.value = 'status_desc';
    }

    // Wait for Supabase in parallel with UI setup (max 2 seconds)
    const supabaseReady = await waitForSupabase(2000);
    
    if (!supabaseReady) {
      console.error('Supabase client not initialized');
      // Show error state in UI
      return;
    }

    // Load data in optimized order - users first, then everything in parallel
    // Use cached users if available
    const cachedUsers = sessionStorage.getItem('cachedUsers');
    const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
    const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
    
    if (cachedUsers && cacheAge < 300000) { // 5 minutes cache
      allUsers = JSON.parse(cachedUsers);
    } else {
      await loadAllUsers();
      sessionStorage.setItem('cachedUsers', JSON.stringify(allUsers));
      sessionStorage.setItem('cachedUsersTime', Date.now().toString());
    }

    // Load all dashboard data in parallel
    await Promise.all([
      loadRecentUpdates(),
      updateYourStats(),
      loadAssignedAudits(),
      loadNotifications()
    ]);

    // Populate filter options after loading data (non-blocking)
    populateFilters().catch(err => console.error('Error populating filters:', err));

  } catch (error) {
    console.error('Error initializing dashboard:', error);
  }
}

function setupEventListeners() {
  // Week navigation buttons
  const prevWeekBtn = document.getElementById('prevWeekBtn');
  const nextWeekBtn = document.getElementById('nextWeekBtn');
  if (prevWeekBtn) {
    prevWeekBtn.addEventListener('click', () => navigateWeek(-1));
  }
  if (nextWeekBtn) {
    nextWeekBtn.addEventListener('click', () => navigateWeek(1));
  }

  // Date button
  const dateBtn = document.getElementById('dateBtn');
  if (dateBtn) {
    dateBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const dropdown = document.getElementById('dateDropdown');
      if (dropdown) {
        dropdown.classList.toggle('active');
      }
    });
  }

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.date-picker-dropdown')) {
      const dropdown = document.getElementById('dateDropdown');
      if (dropdown) {
        dropdown.classList.remove('active');
      }
    }
  });

  // Filter button
  const filterBtn = document.getElementById('filterBtn');
  if (filterBtn) {
    filterBtn.addEventListener('click', () => {
      const panel = document.getElementById('filterPanel');
      if (panel) {
        panel.classList.toggle('active');
        filterBtn.classList.toggle('active');
      }
    });
  }
}

function updateUserAvatar(userInfo) {
  const avatarEl = document.getElementById('userAvatar');
  if (!avatarEl) return;

  if (userInfo.avatar) {
    avatarEl.innerHTML = `<img src="${userInfo.avatar}" alt="${userInfo.name || 'User'}" class="w-full h-full rounded-full object-cover">`;
  } else if (userInfo.name) {
    const initials = userInfo.name.split(' ').map(n => n.charAt(0)).join('').toUpperCase().slice(0, 2);
    avatarEl.innerHTML = `<span class="text-xs font-semibold">${initials}</span>`;
  }
}

async function loadAllUsers() {
  try {
    const { data, error } = await window.supabaseClient
      .from('users')
      .select('email, name, role, channel, quality_mentor')
      .eq('is_active', true);
    
    if (error) throw error;
    allUsers = data || [];
  } catch (error) {
    console.error('Error loading users:', error);
    allUsers = [];
  }
}

async function loadRecentUpdates() {
  try {
    const updatesFeed = document.getElementById('updatesFeed');
    if (!updatesFeed) return;

    const period = getCurrentPeriodDates();
    const cacheKey = getCacheKey('recentUpdates', currentUserEmail, period);
    
    // Check cache first and render immediately
    const cachedUpdates = getCachedData(cacheKey);
    if (cachedUpdates) {
      console.log('Rendering cached recent updates immediately');
      renderRecentUpdatesFromData(cachedUpdates);
    }
    
    // Always fetch fresh data in background
    fetchAndCacheRecentUpdates(cacheKey, period);
  } catch (error) {
    console.error('Error loading recent updates:', error);
  }
}

async function fetchAndCacheRecentUpdates(cacheKey, period) {
  try {
    let allUpdates = [];

    if (isAgent) {
      // For agents: Only show completed audits and reversals (not pending/in_progress assignments)
      
      // 1. Load completed audits from scorecard tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('id, name, table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        
        // Parallelize all scorecard queries
        const auditPromises = scorecards.map(async (scorecard) => {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('*')
              .eq('employee_email', currentUserEmail)
              .order('submitted_at', { ascending: false })
              .limit(20);
            
            if (!error && audits && audits.length > 0) {
              // Client-side filtering with exact email match
              const filteredAudits = audits.filter(audit => {
                const emailToCheck = audit.employee_email;
                if (!emailToCheck) return false;
                return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
              });
              
              return filteredAudits.map(audit => {
                const auditorEmail = (audit.auditor_email || '').toLowerCase().trim();
                const auditorUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === auditorEmail);
                const auditorName = auditorUser?.name || audit.auditor_name || audit.auditor_email?.split('@')[0] || 'Unknown';
                
                return {
                  id: `audit-${audit.id}`,
                  type: 'audit_completed',
                  displayName: auditorName,
                  displayEmail: audit.auditor_email,
                  timestamp: audit.submitted_at || audit.audit_timestamp,
                  status: 'completed',
                  interactionId: audit.interaction_id || audit.interactionId,
                  scorecardId: scorecard.id,
                  scorecardTable: scorecard.table_name,
                  auditId: audit.id
                };
              });
            }
            return [];
          } catch (err) {
            console.warn(`Error loading audits from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const auditResults = await Promise.all(auditPromises);
        allUpdates.push(...auditResults.flat());
      }
      
      // 2. Load reversals (both requested and responded) - parallelized
      if (!scError && scorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        const reversalFilterField = 'employee_email';
        
        // Parallelize all reversal queries
        const reversalPromises = scorecards.map(async (scorecard) => {
          try {
            // Query reversals - get all reversals and sort client-side to prioritize recent responses
            const { data: reversals, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('id, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, reversal_status, acknowledgement_status, interaction_id, interactionId, submitted_at')
              .not('reversal_requested_at', 'is', null)
              .order('reversal_requested_at', { ascending: false })
              .limit(200);
            
            if (!error && reversals && reversals.length > 0) {
              // Sort reversals: prioritize those with recent responses
              reversals.sort((a, b) => {
                const aResponded = a.reversal_responded_at ? new Date(a.reversal_responded_at).getTime() : 0;
                const bResponded = b.reversal_responded_at ? new Date(b.reversal_responded_at).getTime() : 0;
                if (aResponded !== bResponded) {
                  return bResponded - aResponded; // Most recent responses first
                }
                // If both have no response or same response time, sort by request time
                const aRequested = new Date(a.reversal_requested_at).getTime();
                const bRequested = new Date(b.reversal_requested_at).getTime();
                return bRequested - aRequested;
              });
              
              // Filter by email first
              let filteredReversals = reversals.filter(rev => {
                const emailToCheck = rev[reversalFilterField];
                if (!emailToCheck) return false;
                return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
              });
              
              // For agents: Apply the same filtering logic as reversal.html
              // Show reversals that need acknowledgement (pending, approved but not acknowledged, rejected but not acknowledged)
              if (isAgent) {
                filteredReversals = filteredReversals.filter(reversal => {
                  const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus || '';
                  const isAcknowledged = acknowledgementStatus && (
                    acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                    acknowledgementStatus === 'Acknowledged'
                  );
                  
                  // Show if:
                  // 1. Not approved yet (pending) AND not acknowledged
                  // 2. Approved but not acknowledged
                  // 3. Rejected but not acknowledged
                  const isPending = reversal.reversal_approved === null;
                  const isApproved = reversal.reversal_approved === true || reversal.reversal_approved === 'true' || reversal.reversal_approved === 1 || reversal.reversal_approved === '1';
                  const isRejected = reversal.reversal_approved === false || reversal.reversal_approved === 'false' || reversal.reversal_approved === 0 || reversal.reversal_approved === '0';
                  
                  return !isAcknowledged && (isPending || isApproved || isRejected);
                });
              }
              
              // Debug logging
              console.log(`Found ${filteredReversals.length} reversals for ${normalizedCurrentEmail} (isAgent: ${isAgent})`, filteredReversals.map(r => ({
                  id: r.id,
                  reversal_approved: r.reversal_approved,
                  reversal_status: r.reversal_status,
                acknowledgement_status: r.acknowledgement_status,
                  reversal_responded_at: r.reversal_responded_at,
                  reversal_requested_at: r.reversal_requested_at
                })));
              
              const updates = [];
              filteredReversals.forEach(reversal => {
                const auditorEmail = (reversal.auditor_email || '').toLowerCase().trim();
                const auditorUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === auditorEmail);
                const auditorName = auditorUser?.name || reversal.auditor_email?.split('@')[0] || 'Unknown';
                const interactionId = reversal.interaction_id || reversal.interactionId || 'N/A';
                
                // Determine reversal status - check if it's been responded to first, then check acknowledgement
                const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus;
                const isAcknowledged = acknowledgementStatus && (
                  acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                  acknowledgementStatus === 'Acknowledged'
                );
                
                let status = null;
                
                // Use reversal_status column if available (newer format)
                if (reversal.reversal_status && reversal.reversal_status !== 'Pending') {
                  status = reversal.reversal_status;
                }
                // If reversal was responded to, check approval status (fallback for older data)
                else if (reversal.reversal_responded_at) {
                  const approved = reversal.reversal_approved;
                  if (approved === true || approved === 'true' || approved === 1 || approved === '1') {
                    status = 'Approved';
                  } else if (approved === false || approved === 'false' || approved === 0 || approved === '0') {
                    status = 'Rejected';
                  } else {
                    status = 'Pending';
                  }
                }
                // If reversal was requested but not responded to yet
                else if (reversal.reversal_requested_at && !reversal.reversal_responded_at) {
                  status = 'Pending';
                }
                
                // For agents: Show all reversals that appear in reversal.html
                // This includes: pending reversals, approved but not acknowledged, rejected but not acknowledged
                // Since we've already filtered to only show these, we should add updates for all of them
                
                // Add reversal request update (for pending reversals)
                if (status === 'Pending' && reversal.reversal_requested_at) {
                  updates.push({
                    id: `reversal-request-${reversal.id}`,
                    type: 'reversal_requested',
                    displayName: auditorName,
                    displayEmail: reversal.auditor_email,
                    timestamp: reversal.reversal_requested_at,
                    status: 'reversal_requested',
                    interactionId: interactionId,
                    scorecardId: scorecard.id,
                    scorecardTable: scorecard.table_name,
                    auditId: reversal.id
                  });
                }
                
                // Add status change update when reversal has been approved/rejected but NOT yet acknowledged
                // For employees, we want to show when their reversal has been approved or rejected (so they can acknowledge it)
                if (status && (status === 'Approved' || status === 'Rejected') && !isAcknowledged) {
                  const statusText = status === 'Approved' ? 'approved' : 'rejected';
                  
                  // Use reversal_responded_at if available, otherwise use reversal_requested_at
                  const statusTimestamp = reversal.reversal_responded_at || reversal.reversal_requested_at;
                  
                  // Debug logging
                      console.log(`Adding reversal status update for ${reversal.id}:`, {
                        status,
                        statusText,
                    timestamp: statusTimestamp,
                    isAcknowledged,
                    acknowledgementStatus,
                    reversal_approved: reversal.reversal_approved,
                    reversal_status: reversal.reversal_status,
                    reversal_responded_at: reversal.reversal_responded_at
                  });
                    
                    updates.push({
                      id: `reversal-status-${reversal.id}`,
                      type: 'reversal_status_update',
                      displayName: auditorName,
                      displayEmail: reversal.auditor_email,
                    timestamp: statusTimestamp,
                      status: status,
                      statusText: statusText,
                      interactionId: interactionId,
                      scorecardId: scorecard.id,
                      scorecardTable: scorecard.table_name,
                      auditId: reversal.id
                    });
                }
              });
              return updates;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        allUpdates.push(...reversalResults.flat());
      }
      
    } else {
      // For auditors: Show all assignment status changes (pending, in_progress, completed) from audit tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('id, name, table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        
        const assignmentPromises = scorecards.map(async (scorecard) => {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('*')
              .eq('auditor_email', currentUserEmail)
              .in('audit_status', ['pending', 'in_progress', 'completed'])
              .order('assignment_created_at', { ascending: false })
              .limit(20);
            
            if (!error && audits) {
              return audits.map(audit => ({
                ...audit,
                status: audit.audit_status,
                created_at: audit.assignment_created_at || audit.created_at,
                completed_at: audit.completed_at || (audit.audit_status === 'completed' ? audit.submitted_at : null)
              }));
            }
            return [];
          } catch (err) {
            console.warn(`Error loading from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const assignmentResults = await Promise.all(assignmentPromises);
        const filteredAssignments = assignmentResults.flat().filter(assignment => {
          const auditorEmail = (assignment.auditor_email || '').toLowerCase().trim();
          return auditorEmail === normalizedCurrentEmail;
        });
        
        filteredAssignments.forEach(assignment => {
          const employeeEmail = (assignment.employee_email || '').toLowerCase().trim();
          const employeeUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
          const employeeName = employeeUser?.name || assignment.employee_name || assignment.employee_email?.split('@')[0] || 'Unknown';
          
          allUpdates.push({
            id: `assignment-${assignment.id}`,
            type: 'assignment',
            displayName: employeeName,
            displayEmail: assignment.employee_email,
            timestamp: assignment.status === 'completed' && assignment.completed_at 
              ? assignment.completed_at 
              : assignment.created_at,
            status: assignment.status,
            assignmentId: assignment.id
          });
        });
      }
      
      // Also load reversals for auditors - parallelized
      // For auditors: Show only unprocessed reversals (same as reversal.html)
      const { data: reversalScorecards, error: reversalScError } = await window.supabaseClient
        .from('scorecards')
        .select('id, name, table_name')
        .eq('is_active', true);
      
      if (!reversalScError && reversalScorecards) {
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        const reversalFilterField = 'auditor_email';
        
        // Parallelize all reversal queries
        const reversalPromises = reversalScorecards.map(async (scorecard) => {
          try {
            // For auditors: Only get unprocessed reversals (reversal_approved is null) - same as reversal.html
            const { data: reversals, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('id, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, reversal_status, interaction_id, interactionId')
              .not('reversal_requested_at', 'is', null)
              .is('reversal_approved', null) // Only unprocessed reversals
              .order('reversal_requested_at', { ascending: false })
              .limit(50);
            
            if (!error && reversals && reversals.length > 0) {
              // Filter by email
              const filteredReversals = reversals.filter(rev => {
                const emailToCheck = rev[reversalFilterField];
                if (!emailToCheck) return false;
                return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
              });
              
              console.log(`Found ${filteredReversals.length} unprocessed reversals for auditor ${normalizedCurrentEmail}`);
              
              const updates = [];
              // For auditors: These are all unprocessed reversals (same as what appears in reversal.html)
              filteredReversals.forEach(reversal => {
                const employeeEmail = (reversal.employee_email || '').toLowerCase().trim();
                const employeeUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
                const employeeName = employeeUser?.name || reversal.employee_email?.split('@')[0] || 'Unknown';
                const interactionId = reversal.interaction_id || reversal.interactionId || 'N/A';
                
                // Add update for unprocessed reversal request (these appear in reversal.html)
                if (reversal.reversal_requested_at) {
                  updates.push({
                    id: `reversal-request-${reversal.id}`,
                    type: 'reversal_requested',
                    displayName: employeeName,
                    displayEmail: reversal.employee_email,
                    timestamp: reversal.reversal_requested_at,
                    status: 'reversal_requested',
                    interactionId: interactionId,
                    scorecardId: scorecard.id,
                    scorecardTable: scorecard.table_name,
                    auditId: reversal.id
                  });
                }
              });
              return updates;
            }
            return [];
          } catch (err) {
            console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        allUpdates.push(...reversalResults.flat());
      }
    }

    // Apply date filter to updates (but always include recent reversal status updates for agents)
    // Use week filter if date range is not set
    const period = getCurrentPeriodDates();
    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    allUpdates = allUpdates.filter(update => {
      if (!update.timestamp) return false;
      
      // For agents, always include reversal status updates from the last 7 days
      if (isAgent && update.type === 'reversal_status_update') {
        const updateDate = new Date(update.timestamp);
        if (updateDate >= sevenDaysAgo) {
          return true; // Always show recent reversal status updates
        }
      }
      
      return isDateInRange(update.timestamp, period.start, period.end);
    });
    
    // Sort all updates by timestamp (most recent first)
    allUpdates.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    // Limit to 15 most recent
    allUpdates = allUpdates.slice(0, 15);
    
    // Cache the fresh data
    setCachedData(cacheKey, allUpdates);
    
    // Update UI with fresh data
    console.log('Updating UI with fresh recent updates');
    renderRecentUpdatesFromData(allUpdates);
  } catch (error) {
    console.error('Error fetching recent updates:', error);
  }
}

function renderRecentUpdatesFromData(allUpdates) {
  const updatesFeed = document.getElementById('updatesFeed');
  if (!updatesFeed) return;
  
  // Count reversal status updates for agents
  if (isAgent) {
    const reversalStatusUpdates = allUpdates.filter(u => u.type === 'reversal_status_update');
    const reversalCountEl = document.getElementById('reversalUpdatesCount');
    if (reversalCountEl) {
      if (reversalStatusUpdates.length > 0) {
        reversalCountEl.textContent = reversalStatusUpdates.length;
        reversalCountEl.style.display = 'inline-flex';
      } else {
        reversalCountEl.style.display = 'none';
      }
    }
  }

  if (allUpdates.length === 0) {
    updatesFeed.innerHTML = `
      <div class="px-4 py-6 text-center text-gray-500 text-xs">
        <p>No recent updates</p>
      </div>
    `;
    return;
  }

  updatesFeed.innerHTML = allUpdates.map(update => {
      const timestamp = formatTimestamp(update.timestamp);
      const initials = getInitials(update.displayName);
      
      let statusText = '';
      if (update.type === 'audit_completed') {
        statusText = 'completed your audit';
      } else if (update.type === 'reversal_requested') {
        statusText = isAgent 
          ? `You requested reversal for audit ${update.interactionId || ''}`
          : `requested reversal for audit ${update.interactionId || ''}`;
      } else if (update.type === 'reversal_status_update') {
        const statusDisplay = update.status === 'Approved' ? 'approved' : update.status === 'Rejected' ? 'rejected' : update.status === 'Acknowledged' ? 'acknowledged' : 'updated';
        statusText = isAgent
          ? `Your reversal request has been ${statusDisplay}`
          : `Reversal request for audit ${update.interactionId || ''} has been ${statusDisplay}`;
      } else if (update.type === 'reversal_responded') {
        statusText = 'responded to your reversal request';
      } else {
        statusText = getStatusText(update.status, isAgent);
      }
      
      let onClickAction = '';
      if (update.type === 'audit_completed' || update.type === 'reversal_requested' || update.type === 'reversal_responded' || update.type === 'reversal_status_update') {
        onClickAction = `onclick="viewAuditDetails('${update.auditId}', '${update.scorecardId || ''}', '${update.scorecardTable || ''}')"`;
      } else if (update.assignmentId) {
        onClickAction = `onclick="viewAudit('${update.assignmentId}')"`;
      }

      // Determine styling for reversal status updates
      let bgColor = 'bg-primary/10';
      let textColor = 'text-primary';
      if (update.type === 'reversal_status_update') {
        if (update.status === 'Approved') {
          bgColor = 'bg-success/10';
          textColor = 'text-success';
        } else if (update.status === 'Rejected') {
          bgColor = 'bg-error/10';
          textColor = 'text-error';
        } else if (update.status === 'Acknowledged') {
          bgColor = 'bg-primary/10';
          textColor = 'text-primary';
        } else {
          bgColor = 'bg-warning/10';
          textColor = 'text-warning';
        }
      } else if (update.type === 'reversal_requested') {
        bgColor = 'bg-warning/10';
        textColor = 'text-warning';
      }

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer" ${onClickAction}>
          <div class="flex items-start gap-2.5">
            <div class="w-7 h-7 rounded-full ${bgColor} flex items-center justify-center flex-shrink-0">
              <span class="text-xs font-semibold ${textColor}">${initials}</span>
            </div>
            <div class="flex-1 min-w-0">
              <p class="text-xs text-gray-900 leading-snug">
                ${isAgent && (update.type === 'reversal_requested' || update.type === 'reversal_status_update')
                  ? statusText
                  : `<span class="font-medium">${escapeHtml(update.displayName)}</span> ${statusText}`
                }
              </p>
              <p class="text-[10px] text-gray-500 mt-0.5">${timestamp}</p>
            </div>
          </div>
        </div>
      `;
    }).join('');
}

async function loadAssignedAudits() {
  try {
    console.log('Loading audits for user:', currentUserEmail, 'Role:', currentUserRole, 'IsAgent:', isAgent);
    
    const period = getCurrentPeriodDates();
    const cacheKey = getCacheKey('assignedAudits', currentUserEmail, period);
    
    // Check cache first and render immediately
    const cachedAudits = getCachedData(cacheKey);
    if (cachedAudits) {
      console.log('Rendering cached assigned audits immediately');
      assignedAudits = cachedAudits;
      allAssignments = cachedAudits;
      renderAssignedAudits();
    }
    
    // Always fetch fresh data in background
    fetchAndCacheAssignedAudits(cacheKey, period);
  } catch (error) {
    console.error('Error loading assigned audits:', error);
  }
}

async function fetchAndCacheAssignedAudits(cacheKey, period) {
  try {
    if (isAgent) {
      // For employees: Load completed audits from scorecard tables
      await loadCompletedAuditsForEmployee();
    } else {
      // For auditors: Load pending/in-progress assignments from audit_assignments
      await loadPendingAssignmentsForAuditor();
    }

    // Cache the fresh data
    setCachedData(cacheKey, assignedAudits);
    
    // Update UI with fresh data
    console.log('Updating UI with fresh assigned audits');
    renderAssignedAudits();
  } catch (error) {
    console.error('Error fetching assigned audits:', error);
    document.getElementById('assignedAuditsList').innerHTML = `
      <div class="px-4 py-8 text-center text-red-500 text-xs">
        <p>Error loading audits</p>
      </div>
    `;
  }
}

async function loadCompletedAuditsForEmployee() {
  // Load all scorecards to query audit tables
  const { data: scorecards, error: scError } = await window.supabaseClient
    .from('scorecards')
    .select('id, name, table_name, scoring_type')
    .eq('is_active', true);
  
  if (scError) throw scError;
  
  let combinedAudits = [];
  const auditFilterField = 'employee_email';
  
  console.log('Loading completed audits for employee, filtering by:', auditFilterField, 'for email:', currentUserEmail);
  
  // Load audits from all scorecard tables
  for (const scorecard of (scorecards || [])) {
      try {
        // Try with exact match first (case-sensitive)
        const { data, error } = await window.supabaseClient
          .from(scorecard.table_name)
          .select('*')
          .order('submitted_at', { ascending: false })
          .limit(500); // Get more to filter client-side
        
        if (error) {
          console.warn(`Error loading from ${scorecard.table_name}:`, error);
          continue;
        }
        
        if (data && data.length > 0) {
          console.log(`Found ${data.length} audits in ${scorecard.table_name} before filtering`);
          
          // Client-side filtering with exact email match (case-insensitive)
          let filteredAudits = data.filter(audit => {
            const emailToCheck = audit[auditFilterField];
            if (!emailToCheck) return false;
            
            const normalizedEmailToCheck = emailToCheck.toLowerCase().trim();
            const matches = normalizedEmailToCheck === currentUserEmail;
            
            if (!matches && auditFilterField === 'employee_email') {
              // Debug: log mismatches for employees
              console.log(`Mismatch in ${scorecard.table_name}:`, {
                auditId: audit.id,
                expectedEmail: currentUserEmail,
                foundEmail: emailToCheck,
                normalizedFound: normalizedEmailToCheck,
                employee_email: audit.employee_email,
                employee_name: audit.employee_name
              });
            }
            
            return matches;
          });
          
          // Apply date filter (week or date range)
          const period = getCurrentPeriodDates();
          filteredAudits = filteredAudits.filter(audit => {
            const auditDate = audit.submitted_at || audit.audit_timestamp;
            if (!auditDate) return false;
            return isDateInRange(auditDate, period.start, period.end);
          });
          
          // Apply channel filter
          if (currentFilters.channel) {
            filteredAudits = filteredAudits.filter(audit => audit.channel === currentFilters.channel);
          }
          
          console.log(`After filtering: ${filteredAudits.length} audits match for ${currentUserEmail}`);
          
          // Debug: Log the filtered audits to verify they're correct
          if (isAgent && filteredAudits.length > 0) {
            console.log('Filtered audits for employee:', filteredAudits.map(a => ({
              id: a.id,
              employee_email: a.employee_email,
              employee_name: a.employee_name,
              auditor_email: a.auditor_email,
              auditor_name: a.auditor_name
            })));
          }
          
          // Add scorecard info to each audit
          const auditsWithScorecard = filteredAudits.map(audit => ({
            ...audit,
            _scorecard_id: scorecard.id,
            _scorecard_name: scorecard.name,
            _scorecard_table: scorecard.table_name,
            _scoring_type: scorecard.scoring_type,
            _isAssignment: false
          }));
          combinedAudits = combinedAudits.concat(auditsWithScorecard);
        }
      } catch (err) {
        console.warn(`Exception loading from ${scorecard.table_name}:`, err);
        continue;
      }
    }
    
    // Sort by submitted_at descending
    combinedAudits.sort((a, b) => {
      const dateA = new Date(a.submitted_at || a.audit_timestamp || 0);
      const dateB = new Date(b.submitted_at || b.audit_timestamp || 0);
      return dateB - dateA;
    });
    
    // Final verification: Ensure all audits belong to current user
    const invalidAudits = combinedAudits.filter(audit => {
      const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
      return auditEmployeeEmail !== currentUserEmail;
    });
    
    if (invalidAudits.length > 0) {
      console.error('CRITICAL: Found audits that do not belong to current user:', invalidAudits);
      combinedAudits = combinedAudits.filter(audit => {
        const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
        return auditEmployeeEmail === currentUserEmail;
      });
    }
    
    // Limit total results
    combinedAudits = combinedAudits.slice(0, 50);
    
    console.log(`Final completed audits count: ${combinedAudits.length} for employee ${currentUserEmail}`);
    
    assignedAudits = combinedAudits;
    allAssignments = combinedAudits;
}

async function loadPendingAssignmentsForAuditor() {
  // Load pending and in-progress assignments from audit_assignments table
  const { data, error } = await window.supabaseClient
    .from('audit_assignments')
    .select(`
      *,
      scorecards:scorecard_id (
        id,
        name,
        table_name
      )
    `)
    .eq('auditor_email', currentUserEmail)
    .in('status', ['pending', 'in_progress'])
    .order('created_at', { ascending: false });
  
  if (error) {
    console.error('Error loading assignments:', error);
    throw error;
  }
  
  // Normalize and filter client-side for exact match
  const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
  let filteredAssignments = (data || []).filter(assignment => {
    const auditorEmail = (assignment.auditor_email || '').toLowerCase().trim();
    return auditorEmail === normalizedCurrentEmail;
  });
  
  // Apply date filter (week or date range)
  const period = getCurrentPeriodDates();
  filteredAssignments = filteredAssignments.filter(assignment => {
    const assignmentDate = assignment.created_at;
    if (!assignmentDate) return false;
    return isDateInRange(assignmentDate, period.start, period.end);
  });
  
  // Apply channel filter
  if (currentFilters.channel) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.channel === currentFilters.channel);
  }
  
  // Apply status filter
  if (currentFilters.status) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.status === currentFilters.status);
  }
  
  // Apply agent filter
  if (currentFilters.agent) {
    filteredAssignments = filteredAssignments.filter(assignment => assignment.employee_email === currentFilters.agent);
  }
  
  console.log(`Found ${filteredAssignments.length} pending/in-progress assignments for auditor ${currentUserEmail}`);
  
  // Map assignments to a format similar to audits for rendering
  assignedAudits = filteredAssignments.map(assignment => ({
    ...assignment,
    _scorecard_id: assignment.scorecard_id,
    _scorecard_name: assignment.scorecards?.name || 'Unknown Scorecard',
    _scorecard_table: assignment.scorecards?.table_name || '',
    _isAssignment: true,
    // Map assignment fields to audit-like fields for rendering
    id: assignment.id,
    employee_name: assignment.employee_name,
    employee_email: assignment.employee_email,
    auditor_email: assignment.auditor_email,
    status: assignment.status,
    created_at: assignment.created_at
  }));
  
  allAssignments = assignedAudits;
}

function renderAssignedAudits() {
  const list = document.getElementById('assignedAuditsList');
  const countEl = document.getElementById('pendingCount');

  if (!list) return;

  // Update count
  if (countEl) countEl.textContent = assignedAudits.length;

  if (assignedAudits.length === 0) {
    const emptyMessage = isAgent 
      ? 'Your completed audits will appear here'
      : 'No pending audits assigned';
    list.innerHTML = `
      <div class="px-4 py-8 text-center text-gray-500 text-xs">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        <p class="font-medium text-gray-700 mb-1">No audits found</p>
        <p class="text-gray-500">${emptyMessage}</p>
      </div>
    `;
    return;
  }

  // Sort audits
  const sorted = [...assignedAudits];
  sortAudits(sorted);

  list.innerHTML = sorted.map(audit => {
    // Check if this is an assignment (pending audit) or a completed audit
    const isAssignment = audit._isAssignment === true;
    
    if (isAssignment) {
      // Render assignment (pending audit) for auditors
      const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
      const displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
      const displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
      const displayEmail = audit.employee_email || '';
      const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
      const initials = getInitials(displayName);
      
      let statusBadge = '';
      if (audit.status === 'in_progress') {
        statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-yellow-100 text-yellow-800">In Progress</span>';
      } else {
        statusBadge = '<span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-800">Pending</span>';
      }
      
      const requestDate = formatTimestamp(audit.created_at);
      const buttonText = audit.status === 'in_progress' ? 'Continue' : 'Start';

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" onclick="viewAudit('${audit.id}')">
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-2.5 flex-1 min-w-0">
              <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
                ${initials}
              </div>
              <div class="flex-1 min-w-0">
                <div class="flex items-center gap-1.5 mb-0.5">
                  <h4 class="text-xs font-semibold text-gray-900 truncate">
                    ${escapeHtml(displayName)}
                  </h4>
                </div>
                <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                  <span class="truncate">${escapeHtml(displayEmail)}</span>
                  <span class="text-gray-300"></span>
                  <span class="font-medium text-gray-700">${escapeHtml(scorecardName)}</span>
                  <span class="text-gray-300"></span>
                  <span>${requestDate}</span>
                </p>
              </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              ${statusBadge}
              <button onclick="event.stopPropagation(); viewAudit('${audit.id}')" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
                ${buttonText}
              </button>
            </div>
          </div>
        </div>
      `;
    } else {
      // Render completed audit for employees
      // Verify the audit belongs to the current user (for debugging)
      if (isAgent) {
        const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
        if (auditEmployeeEmail !== currentUserEmail) {
          console.error('CRITICAL: Audit does not belong to current user!', {
            auditId: audit.id,
            auditEmployeeEmail,
            currentUserEmail,
            audit
          });
        }
      }
      
      // For agents, show auditor info; for auditors, show employee info
      let displayUser, displayName, displayEmail;
      if (isAgent) {
        // For employees, show who audited them (the auditor)
        const auditorEmail = (audit.auditor_email || '').toLowerCase().trim();
        displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === auditorEmail);
        displayName = displayUser?.name || audit.auditor_name || audit.auditor_email?.split('@')[0] || 'Unknown';
        displayEmail = audit.auditor_email || '';
      } else {
        // For auditors, show who they audited (the employee)
        const employeeEmail = (audit.employee_email || '').toLowerCase().trim();
        displayUser = allUsers.find(u => (u.email || '').toLowerCase().trim() === employeeEmail);
        displayName = audit.employee_name || displayUser?.name || audit.employee_email?.split('@')[0] || 'Unknown';
        displayEmail = audit.employee_email || '';
      }
      
      const scorecardName = audit._scorecard_name || 'Unknown Scorecard';
      const initials = getInitials(displayName);
      
      // Get passing status
      const passingStatus = audit.passing_status || audit.passingStatus || 'Unknown';
      const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
      const statusColor = normalizedStatus === 'Passed' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
      const statusIcon = normalizedStatus === 'Passed' ? '' : '';
      
      const submittedDate = formatTimestamp(audit.submitted_at || audit.audit_timestamp);
      const averageScore = audit.average_score || audit.averageScore || '0';
      const totalErrors = audit.total_errors_count || audit.totalErrorsCount || '0';
      const interactionId = audit.interaction_id || audit.interactionId || 'N/A';
      const channel = audit.channel || 'N/A';
      
      // Debug logging for reversal status
      if (audit.reversal_requested_at) {
        console.log('Audit with reversal:', {
          id: audit.id,
          employee_email: audit.employee_email,
          reversal_requested_at: audit.reversal_requested_at,
          reversal_responded_at: audit.reversal_responded_at,
          reversal_approved: audit.reversal_approved,
          acknowledgement_status: audit.acknowledgement_status
        });
      }
      
      const reversalStatusChip = getReversalStatusChip(audit);
      const acknowledgmentStatusChip = getAcknowledgmentStatusChip(audit);

      return `
        <div class="px-4 py-2.5 hover:bg-gray-50 transition-colors cursor-pointer border-b border-gray-100 last:border-0" onclick="viewAuditDetails('${audit.id}', '${audit._scorecard_id || ''}', '${audit._scorecard_table || ''}')">
          <div class="flex items-center justify-between gap-3">
            <div class="flex items-center gap-2.5 flex-1 min-w-0">
              <div class="w-8 h-8 rounded bg-primary text-white flex items-center justify-center text-xs font-semibold flex-shrink-0">
                ${initials}
              </div>
              <div class="flex-1 min-w-0">
                ${isAgent ? `
                  <!-- For employees: 2 rows, info compact -->
                  <!-- Row 1: Interaction ID + Scorecard + Passing Status -->
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(interactionId)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor}">
                      ${statusIcon} ${normalizedStatus}
                    </span>
                  </div>
                  <!-- Row 2: Auditor name  Channel  Score  Errors  Date -->
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span class="font-medium text-gray-700">${escapeHtml(displayName)}</span>
                    <span class="text-gray-300"></span>
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="font-medium text-gray-700">${averageScore}%</span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                ` : `
                  <!-- For auditors: 2 rows, info compact -->
                  <!-- Row 1: Employee name + Scorecard -->
                  <div class="flex items-center gap-1.5 mb-0.5 flex-wrap">
                    <h4 class="text-xs font-semibold text-gray-900 truncate">
                      ${escapeHtml(displayName)}
                    </h4>
                    ${audit._scorecard_name ? `
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-semibold bg-gray-100 text-gray-700">
                        ${escapeHtml(audit._scorecard_name)}
                      </span>
                    ` : ''}
                  </div>
                  <!-- Row 2: Interaction ID  Channel  Score  Errors  Date -->
                  <p class="text-[10px] text-gray-600 flex items-center gap-1 flex-wrap">
                    <span>${escapeHtml(interactionId)}</span>
                    <span class="text-gray-300"></span>
                    <span>${escapeHtml(channel)}</span>
                    <span class="text-gray-300"></span>
                    <span class="flex flex-col items-start">
                      <span class="font-medium text-gray-700">${averageScore}%</span>
                      <span class="inline-flex items-center px-2 py-0.5 rounded text-[9px] font-semibold ${statusColor} mt-0.5">
                        ${statusIcon} ${normalizedStatus}
                      </span>
                    </span>
                    <span class="text-gray-300"></span>
                    <span>${totalErrors} errors</span>
                    <span class="text-gray-300"></span>
                    <span>${submittedDate}</span>
                  </p>
                `}
              </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              ${acknowledgmentStatusChip}
              ${reversalStatusChip}
              <button onclick="event.stopPropagation(); viewAuditDetails('${audit.id}', '${audit._scorecard_id || ''}', '${audit._scorecard_table || ''}')" class="px-2.5 py-1 bg-primary text-white text-[10px] font-semibold rounded hover:bg-primary-dark transition-colors">
                View Details
              </button>
            </div>
          </div>
        </div>
      `;
    }
  }).join('');
}

function sortAudits(audits) {
  audits.sort((a, b) => {
    const isAssignmentA = a._isAssignment === true;
    const isAssignmentB = b._isAssignment === true;
    
    switch (sortBy) {
      case 'name_asc':
        // For agents, sort by auditor; for auditors, sort by employee
        const nameA = (isAgent ? (a.auditor_name || a.auditor_email || '') : (a.employee_name || a.employee_email || '')).toLowerCase();
        const nameB = (isAgent ? (b.auditor_name || b.auditor_email || '') : (b.employee_name || b.employee_email || '')).toLowerCase();
        return nameA.localeCompare(nameB);
      case 'name_desc':
        const nameA2 = (isAgent ? (a.auditor_name || a.auditor_email || '') : (a.employee_name || a.employee_email || '')).toLowerCase();
        const nameB2 = (isAgent ? (b.auditor_name || b.auditor_email || '') : (b.employee_name || b.employee_email || '')).toLowerCase();
        return nameB2.localeCompare(nameA2);
      case 'status_asc':
        // For assignments, sort by assignment status; for audits, sort by passing status
        if (isAssignmentA && isAssignmentB) {
          const statusOrder = { 'pending': 0, 'in_progress': 1 };
          return (statusOrder[a.status] || 0) - (statusOrder[b.status] || 0);
        }
        const statusA = (a.passing_status || a.passingStatus || '').toLowerCase();
        const statusB = (b.passing_status || b.passingStatus || '').toLowerCase();
        return statusA.localeCompare(statusB);
      case 'status_desc':
        if (isAssignmentA && isAssignmentB) {
          const statusOrder = { 'pending': 0, 'in_progress': 1 };
          return (statusOrder[b.status] || 0) - (statusOrder[a.status] || 0);
        }
        const statusA2 = (a.passing_status || a.passingStatus || '').toLowerCase();
        const statusB2 = (b.passing_status || b.passingStatus || '').toLowerCase();
        return statusB2.localeCompare(statusA2);
      case 'date_asc':
        const dateA = new Date(a.submitted_at || a.audit_timestamp || a.created_at || 0);
        const dateB = new Date(b.submitted_at || b.audit_timestamp || b.created_at || 0);
        return dateA - dateB;
      case 'date_desc':
      default:
        const dateA2 = new Date(a.submitted_at || a.audit_timestamp || a.created_at || 0);
        const dateB2 = new Date(b.submitted_at || b.audit_timestamp || b.created_at || 0);
        return dateB2 - dateA2;
    }
  });
}

function sortAssignedAudits() {
  const select = document.getElementById('auditSortBy');
  if (select) {
    sortBy = select.value;
    renderAssignedAudits();
  }
}

function toggleSortMenu() {
  const menu = document.getElementById('sortMenu');
  if (menu) {
    menu.classList.toggle('hidden');
  }
}

// Close sort menu when clicking outside
document.addEventListener('click', function(event) {
  const sortBtn = document.getElementById('sortBtn');
  const sortMenu = document.getElementById('sortMenu');
  if (sortMenu && sortBtn && !sortMenu.contains(event.target) && !sortBtn.contains(event.target)) {
    sortMenu.classList.add('hidden');
  }
});

// Update your stats (assignment progress)
async function updateYourStats() {
  try {
    if (!currentUserEmail) {
      console.log('No user email found for stats');
      return;
    }
    
    const period = getCurrentPeriodDates();
    const cacheKey = getCacheKey('stats', currentUserEmail, period);
    
    // Check cache first and render immediately
    const cachedStats = getCachedData(cacheKey);
    if (cachedStats) {
      console.log('Rendering cached stats immediately');
      renderStatsFromData(cachedStats);
    }
    
    // Always fetch fresh data in background
    fetchAndCacheStats(cacheKey, period);
  } catch (error) {
    console.error('Error loading stats:', error);
  }
}

async function fetchAndCacheStats(cacheKey, period) {
  try {
    if (!currentUserEmail) {
      console.log('No user email found for stats');
      return;
    }
    
    // Load assignments for current user
    // Filter by employee_email if agent, otherwise by auditor_email
    const filterField = isAgent ? 'employee_email' : 'auditor_email';
    const { data: assignments, error: assignmentsError } = await window.supabaseClient
      .from('audit_assignments')
      .select('*')
      .eq(filterField, currentUserEmail)
      .order('created_at', { ascending: false });
    
    if (assignmentsError) {
      console.error('Error loading assignments for stats:', assignmentsError);
      return;
    }
    
    // Apply date filter to assignments (week or date range)
    let allAssignments = assignments || [];
    const period = getCurrentPeriodDates();
    allAssignments = allAssignments.filter(assignment => {
      const assignmentDate = assignment.created_at;
      if (!assignmentDate) return false;
      return isDateInRange(assignmentDate, period.start, period.end);
    });
    
    const totalAssigned = allAssignments.length;
    const completed = allAssignments.filter(a => a.status === 'completed').length;
    const inProgress = allAssignments.filter(a => a.status === 'in_progress').length;
    const pending = allAssignments.filter(a => a.status === 'pending').length;
    const remaining = pending + inProgress;
    
    // Calculate percentage
    const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
    
    // Calculate working days remaining (assuming 5 working days per week)
    const today = new Date();
    const endOfWeek = new Date(today);
    endOfWeek.setDate(today.getDate() + (5 - today.getDay())); // Friday
    const daysRemaining = Math.max(0, Math.ceil((endOfWeek - today) / (1000 * 60 * 60 * 24)));
    
    // Calculate average audit duration
    let avgDuration = 0;
    let avgDurationText = '-';
    
    try {
      // Get all scorecards to query audit tables
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const auditFilterField = isAgent ? 'employee_email' : 'auditor_email';
        
        // Parallelize all duration queries
        const durationPromises = scorecards.map(async (scorecard) => {
          try {
            const { data: audits, error } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('audit_duration, submitted_at, audit_timestamp')
              .eq(auditFilterField, currentUserEmail)
              .not('audit_duration', 'is', null);
            
            if (!error && audits) {
              // Apply date filter (week or date range)
              const period = getCurrentPeriodDates();
              let filteredAudits = audits.filter(audit => {
                const auditDate = audit.submitted_at || audit.audit_timestamp;
                if (!auditDate) return false;
                return isDateInRange(auditDate, period.start, period.end);
              });
              
              return filteredAudits.map(audit => {
                // Handle duration conversion (new format: seconds, legacy format: minutes)
                let durationInMinutes = 0;
                if (typeof audit.audit_duration === 'number') {
                  const value = audit.audit_duration;
                  if (value >= 1440) {
                    durationInMinutes = value / 60; // Convert seconds to minutes
                  } else {
                    durationInMinutes = value; // Already in minutes
                  }
                } else if (typeof audit.audit_duration === 'string') {
                  const asInt = parseInt(audit.audit_duration);
                  if (!isNaN(asInt)) {
                    if (asInt >= 1440) {
                      durationInMinutes = asInt / 60;
                    } else {
                      durationInMinutes = asInt;
                    }
                  } else {
                    const timeParts = audit.audit_duration.split(':');
                    if (timeParts.length === 2) {
                      const minutes = parseInt(timeParts[0]) || 0;
                      const seconds = parseInt(timeParts[1]) || 0;
                      durationInMinutes = minutes + (seconds / 60);
                    } else if (timeParts.length === 3) {
                      const hours = parseInt(timeParts[0]) || 0;
                      const minutes = parseInt(timeParts[1]) || 0;
                      const seconds = parseInt(timeParts[2]) || 0;
                      durationInMinutes = (hours * 60) + minutes + (seconds / 60);
                    }
                  }
                }
                return durationInMinutes > 0 ? durationInMinutes : null;
              }).filter(Boolean);
            }
            return [];
          } catch (err) {
            console.warn(`Error getting duration from ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const durationResults = await Promise.all(durationPromises);
        const allDurations = durationResults.flat();
        const totalDuration = allDurations.reduce((sum, d) => sum + d, 0);
        const auditCount = allDurations.length;
        
        if (auditCount > 0) {
          avgDuration = totalDuration / auditCount; // Average in minutes
          
          // Format duration (avgDuration is in minutes)
          if (avgDuration >= 60) {
            const hours = Math.floor(avgDuration / 60);
            const minutes = Math.round(avgDuration % 60);
            avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
          } else {
            avgDurationText = `${Math.round(avgDuration)}m`;
          }
        }
      }
    } catch (error) {
      console.error('Error calculating average duration:', error);
    }
    
    // Calculate total audits conducted
    let totalAuditsConducted = 0;
    let totalScoreSum = 0;
    let totalAuditsWithScore = 0;
    let avgQualityScore = 0;
    let avgQualityScoreText = '-';
    let passingCount = 0;
    let notPassingCount = 0;
    
    if (isAgent) {
      // For employees: Count completed audits from scorecard tables
      // Use the same logic as loadCompletedAuditsForEmployee
      try {
        const { data: scorecards, error: scError } = await window.supabaseClient
          .from('scorecards')
          .select('id, name, table_name, scoring_type')
          .eq('is_active', true);
        
        if (!scError && scorecards) {
          const auditFilterField = 'employee_email';
          const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
          
          // Parallelize all audit queries
          const auditPromises = scorecards.map(async (scorecard) => {
            try {
              const { data: audits, error } = await window.supabaseClient
                .from(scorecard.table_name)
                .select('*')
                .order('submitted_at', { ascending: false })
                .limit(500);
              
              if (!error && audits && audits.length > 0) {
                let filteredAudits = audits.filter(audit => {
                  const emailToCheck = audit[auditFilterField];
                  if (!emailToCheck) return false;
                  const normalizedEmailToCheck = emailToCheck.toLowerCase().trim();
                  return normalizedEmailToCheck === normalizedCurrentEmail;
                });
                
                // Apply date filter (week or date range)
                const period = getCurrentPeriodDates();
                filteredAudits = filteredAudits.filter(audit => {
                  const auditDate = audit.submitted_at || audit.audit_timestamp;
                  if (!auditDate) return false;
                  return isDateInRange(auditDate, period.start, period.end);
                });
                
                return filteredAudits.map(audit => {
                  const score = parseFloat(audit.average_score || audit.averageScore || 0);
                  const passingStatus = audit.passing_status || audit.passingStatus || '';
                  const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
                  
                  return { 
                    score: !isNaN(score) ? score : null,
                    passingStatus: normalizedStatus
                  };
                });
              }
              return [];
            } catch (err) {
              console.warn(`Error getting audits from ${scorecard.table_name}:`, err);
              return [];
            }
          });
          
          const auditResults = await Promise.all(auditPromises);
          const allAudits = auditResults.flat();
          totalAuditsConducted = allAudits.length;
          allAudits.forEach(audit => {
            if (audit.score !== null) {
              totalScoreSum += audit.score;
              totalAuditsWithScore++;
            }
            // Count passing/not passing
            if (audit.passingStatus === 'Passed' || audit.passingStatus === 'Passing') {
              passingCount++;
            } else if (audit.passingStatus === 'Not Passed' || audit.passingStatus === 'Not Passing') {
              notPassingCount++;
            }
          });
          
          if (totalAuditsWithScore > 0) {
            avgQualityScore = totalScoreSum / totalAuditsWithScore;
            avgQualityScoreText = `${Math.round(avgQualityScore)}%`;
          }
          
          console.log(`Stats for employee: ${totalAuditsConducted} audits conducted, ${avgQualityScoreText} average score, ${passingCount} passing, ${notPassingCount} not passing`);
        }
      } catch (error) {
        console.error('Error calculating audits conducted and average score:', error);
      }
    } else {
      // For auditors: Count completed audits from scorecard tables (same as average quality score calculation)
      // This ensures we count all audits, even if they don't exist in audit_assignments table
      try {
        const { data: scorecards, error: scError } = await window.supabaseClient
          .from('scorecards')
          .select('id, name, table_name, scoring_type')
          .eq('is_active', true);
        
        if (!scError && scorecards) {
          const auditFilterField = 'auditor_email';
          const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
          const period = getCurrentPeriodDates();
          
          // Parallelize all audit queries - get all audits conducted by this auditor
          // Use the same logic as agents, but filter by auditor_email instead of employee_email
          const auditPromises = scorecards.map(async (scorecard) => {
            try {
              const { data: audits, error } = await window.supabaseClient
                .from(scorecard.table_name)
                .select('*')
                .order('submitted_at', { ascending: false })
                .limit(500);
              
              if (!error && audits && audits.length > 0) {
                // Filter by auditor email (case-insensitive) - same logic as agents use for employee_email
                let filteredAudits = audits.filter(audit => {
                  const emailToCheck = audit[auditFilterField];
                  if (!emailToCheck) return false;
                  const normalizedEmailToCheck = emailToCheck.toLowerCase().trim();
                  return normalizedEmailToCheck === normalizedCurrentEmail;
                });
                
                // Apply date filter (week or date range)
                filteredAudits = filteredAudits.filter(audit => {
                  const auditDate = audit.submitted_at || audit.audit_timestamp;
                  if (!auditDate) return false;
                  return isDateInRange(auditDate, period.start, period.end);
                });
                
                return filteredAudits.map(audit => {
                  const score = parseFloat(audit.average_score || audit.averageScore || 0);
                  const passingStatus = audit.passing_status || audit.passingStatus || '';
                  const normalizedStatus = passingStatus === 'Passing' ? 'Passed' : (passingStatus === 'Not Passing' ? 'Not Passed' : passingStatus);
                  
                  return { 
                    score: !isNaN(score) ? score : null,
                    passingStatus: normalizedStatus
                  };
                });
              }
              return [];
            } catch (err) {
              console.warn(`Error getting audits from ${scorecard.table_name}:`, err);
              return [];
            }
          });
          
          const auditResults = await Promise.all(auditPromises);
          const allAudits = auditResults.flat();
          
          // Count total audits conducted from scorecard tables
          totalAuditsConducted = allAudits.length;
          
          // Calculate average quality score from all audits conducted by this auditor
          allAudits.forEach(audit => {
            if (audit.score !== null) {
              totalScoreSum += audit.score;
              totalAuditsWithScore++;
            }
            // Count passing/not passing
            if (audit.passingStatus === 'Passed' || audit.passingStatus === 'Passing') {
              passingCount++;
            } else if (audit.passingStatus === 'Not Passed' || audit.passingStatus === 'Not Passing') {
              notPassingCount++;
            }
          });
          
          if (totalAuditsWithScore > 0) {
            avgQualityScore = totalScoreSum / totalAuditsWithScore;
            avgQualityScoreText = `${Math.round(avgQualityScore)}%`;
          }
          
          console.log(`Stats for auditor: ${totalAuditsConducted} audits conducted (from scorecard tables), ${avgQualityScoreText} average quality score (from ${totalAuditsWithScore} scored audits filtered by auditor_email), ${passingCount} passed, ${notPassingCount} not passed`);
        }
      } catch (error) {
        console.error('Error calculating audits conducted and average quality score for auditor:', error);
      }
    }
    
    // Calculate reversal counts (active and resolved)
    let activeReversals = 0;
    let resolvedReversals = 0;
    let totalReversals = 0;
    let requiresAcknowledgment = 0;
    
    // For agents: Count audits with acknowledgement_status = 'pending'
    if (isAgent) {
      try {
        const { data: scorecards, error: scError } = await window.supabaseClient
          .from('scorecards')
          .select('table_name')
          .eq('is_active', true);
        
        if (!scError && scorecards) {
          const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
          
          // Parallelize all audit count queries
          const auditPromises = scorecards.map(async (scorecard) => {
            try {
              // Get all audits for this employee and filter client-side
              const { data: allAudits, error: auditError } = await window.supabaseClient
                .from(scorecard.table_name)
                .select('id, employee_email, acknowledgement_status, submitted_at, audit_timestamp')
                .limit(1000);
              
              if (!auditError && allAudits) {
                // Filter by email (case-insensitive) and acknowledgement_status = 'pending'
                let pendingAudits = allAudits.filter(audit => {
                  const emailToCheck = audit.employee_email;
                  if (!emailToCheck) return false;
                  const emailMatches = emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
                  
                  const ackStatus = audit.acknowledgement_status || audit.acknowledgementStatus || '';
                  const isPending = ackStatus && (
                    ackStatus.toLowerCase() === 'pending' || 
                    ackStatus === 'Pending'
                  );
                  
                  return emailMatches && isPending;
                });
                
                // Apply date filter (week or date range)
                const period = getCurrentPeriodDates();
                pendingAudits = pendingAudits.filter(audit => {
                  const auditDate = audit.submitted_at || audit.audit_timestamp;
                  if (!auditDate) return false;
                  return isDateInRange(auditDate, period.start, period.end);
                });
                
                console.log(`Found ${pendingAudits.length} pending audits in ${scorecard.table_name} for ${currentUserEmail}`);
                
                return pendingAudits.length;
              }
              return 0;
            } catch (err) {
              console.warn(`Error counting pending audits in ${scorecard.table_name}:`, err);
              return 0;
            }
          });
          
          const auditCounts = await Promise.all(auditPromises);
          requiresAcknowledgment = auditCounts.reduce((sum, count) => sum + count, 0);
          
          console.log(`Total audits requiring acknowledgment for agent ${currentUserEmail}:`, requiresAcknowledgment);
        }
      } catch (error) {
        console.error('Error calculating acknowledgment count:', error);
      }
    }
    
    // Calculate reversal counts (for reversal card stats)
    try {
      const { data: scorecards, error: scError } = await window.supabaseClient
        .from('scorecards')
        .select('table_name')
        .eq('is_active', true);
      
      if (!scError && scorecards) {
        const reversalFilterField = isAgent ? 'employee_email' : 'auditor_email';
        
        // Parallelize all reversal count queries
        const reversalPromises = scorecards.map(async (scorecard) => {
          try {
            const { data: allReversals, error: allError } = await window.supabaseClient
              .from(scorecard.table_name)
              .select('reversal_requested_at, reversal_responded_at, ' + reversalFilterField)
              .not('reversal_requested_at', 'is', null)
              .limit(500);
            
            if (!allError && allReversals) {
              const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
              
              // Filter by email (case-insensitive)
              let filteredReversals = allReversals.filter(reversal => {
                const emailToCheck = reversal[reversalFilterField];
                if (!emailToCheck) return false;
                return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
              });
              
              // Apply date filter based on reversal_requested_at (week or date range)
              const period = getCurrentPeriodDates();
              filteredReversals = filteredReversals.filter(reversal => {
                const reversalDate = reversal.reversal_requested_at;
                if (!reversalDate) return false;
                return isDateInRange(reversalDate, period.start, period.end);
              });
              
              return filteredReversals.map(reversal => {
                const active = reversal.reversal_requested_at && !reversal.reversal_responded_at;
                const resolved = !!reversal.reversal_responded_at;
                return { active, resolved };
              });
            }
            return [];
          } catch (err) {
            console.warn(`Error counting reversals in ${scorecard.table_name}:`, err);
            return [];
          }
        });
        
        const reversalResults = await Promise.all(reversalPromises);
        const allReversalsData = reversalResults.flat();
        
        // Count all reversals for total/active/resolved stats
        allReversalsData.forEach(reversal => {
          totalReversals++;
          if (reversal.active) activeReversals++;
          if (reversal.resolved) resolvedReversals++;
        });
      }
    } catch (error) {
      console.error('Error calculating reversal counts:', error);
    }
    
    // Collect all stats into an object for caching
    const statsData = {
      totalAssigned,
      completed,
      inProgress,
      pending,
      remaining,
      percentage,
      daysRemaining,
      avgDuration,
      avgDurationText,
      totalAuditsConducted,
      totalScoreSum,
      totalAuditsWithScore,
      avgQualityScore,
      avgQualityScoreText,
      passingCount,
      notPassingCount,
      activeReversals,
      resolvedReversals,
      totalReversals,
      requiresAcknowledgment
    };
    
    // Cache the fresh data
    setCachedData(cacheKey, statsData);
    
    // Update UI with fresh data
    console.log('Updating UI with fresh stats');
    renderStatsFromData(statsData);
    
  } catch (error) {
    console.error('Error updating your stats:', error);
  }
}

function renderStatsFromData(stats) {
  const {
    totalAssigned,
    completed,
    inProgress,
    pending,
    remaining,
    percentage,
    daysRemaining,
    avgDurationText,
    totalAuditsConducted,
    totalAuditsWithScore,
    avgQualityScoreText,
    passingCount,
    notPassingCount,
    activeReversals,
    resolvedReversals,
    totalReversals,
    requiresAcknowledgment
  } = stats;
  
  // Update stat cards
  const statsAuditsConductedCount = document.getElementById('statsAuditsConductedCount');
  const statsRemainingText = document.getElementById('statsRemainingText');
  const statsRemainingProgress = document.getElementById('statsRemainingProgress');
  const statsAvgQualityScore = document.getElementById('statsAvgQualityScore');
  const statsAvgScoreSubtitle = document.getElementById('statsAvgScoreSubtitle');
  const statsPassingCount = document.getElementById('statsPassingCount');
  const statsNotPassingCount = document.getElementById('statsNotPassingCount');
  const statsRemainingCount = document.getElementById('statsRemainingCount');
  const statsInProgressCount = document.getElementById('statsInProgressCount');
  const statsDaysRemaining = document.getElementById('statsDaysRemaining');
  const statsReversalTotalCount = document.getElementById('statsReversalTotalCount');
  const statsReversalActiveCount = document.getElementById('statsReversalActiveCount');
  const statsReversalResolvedCount = document.getElementById('statsReversalResolvedCount');
  const statsRequiresAcknowledgmentCount = document.getElementById('statsRequiresAcknowledgmentCount');
  const requiresAcknowledgmentCard = document.getElementById('requiresAcknowledgmentCard');
  const statsAvgDuration = document.getElementById('statsAvgDuration');
  const statsAvgDurationSubtitle = document.getElementById('statsAvgDurationSubtitle');
  
  // Update Audits Conducted card
  if (statsAuditsConductedCount) statsAuditsConductedCount.textContent = totalAuditsConducted;
  if (statsRemainingText) statsRemainingText.textContent = `${remaining} remaining`;
  
  // Calculate progress bar percentage (completed / total assigned, showing completed portion in green)
  const completedCount = totalAssigned - remaining;
  const progressPercentage = totalAssigned > 0 ? Math.round((completedCount / totalAssigned) * 100) : 0;
  if (statsRemainingProgress) {
    statsRemainingProgress.style.width = `${Math.min(100, progressPercentage)}%`;
    if (progressPercentage > 0) {
      statsRemainingProgress.classList.remove('bg-warning');
      statsRemainingProgress.classList.add('bg-success');
    } else {
      statsRemainingProgress.classList.remove('bg-success');
      statsRemainingProgress.classList.add('bg-warning');
    }
  }
  
  // Update Average Quality Score card
  if (statsAvgQualityScore) statsAvgQualityScore.textContent = avgQualityScoreText;
  if (statsAvgScoreSubtitle) {
    statsAvgScoreSubtitle.textContent = totalAuditsWithScore > 0 ? `from ${totalAuditsWithScore} audits` : 'No audits yet';
  }
  
  // Update passing and not passing count chips
  if (statsPassingCount) {
    const loadingSpan = statsPassingCount.querySelector('span.inline-block');
    if (loadingSpan) {
      loadingSpan.remove();
    }
    const svg = statsPassingCount.querySelector('svg');
    const textSpan = statsPassingCount.querySelector('span:last-child');
    if (svg && textSpan) {
      let nextSibling = svg.nextSibling;
      while (nextSibling && nextSibling !== textSpan) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextSibling;
        toRemove.remove();
      }
      textSpan.textContent = `${passingCount} Passed`;
    }
  }
  if (statsNotPassingCount) {
    const loadingSpan = statsNotPassingCount.querySelector('span.inline-block');
    if (loadingSpan) {
      loadingSpan.remove();
    }
    const svg = statsNotPassingCount.querySelector('svg');
    const textSpan = statsNotPassingCount.querySelector('span:last-child');
    if (svg && textSpan) {
      let nextSibling = svg.nextSibling;
      while (nextSibling && nextSibling !== textSpan) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextSibling;
        toRemove.remove();
      }
      textSpan.textContent = `${notPassingCount} Not Passed`;
    }
  }
  
  // Update other cards
  if (statsRemainingCount) statsRemainingCount.textContent = remaining;
  if (statsInProgressCount) statsInProgressCount.textContent = inProgress;
  if (statsDaysRemaining) statsDaysRemaining.textContent = `${daysRemaining} working day${daysRemaining !== 1 ? 's' : ''} remaining`;
  
  // Update Reversal card
  if (statsReversalTotalCount) statsReversalTotalCount.textContent = totalReversals;
  if (statsReversalActiveCount) statsReversalActiveCount.textContent = activeReversals;
  if (statsReversalResolvedCount) statsReversalResolvedCount.textContent = resolvedReversals;
  
  // Update Requires Acknowledgment card (agents only)
  if (isAgent && statsRequiresAcknowledgmentCount && requiresAcknowledgmentCard) {
    statsRequiresAcknowledgmentCount.textContent = requiresAcknowledgment;
    requiresAcknowledgmentCard.style.display = 'block';
  } else if (requiresAcknowledgmentCard) {
    requiresAcknowledgmentCard.style.display = 'none';
  }
  
  if (statsAvgDuration) statsAvgDuration.textContent = avgDurationText;
  if (statsAvgDurationSubtitle) statsAvgDurationSubtitle.textContent = 'per audit';
}

function viewAudit(assignmentId) {
  window.location.href = `create-audit.html?assignment=${assignmentId}`;
}

function viewAuditDetails(auditId, scorecardId, tableName) {
  window.location.href = `audit-view.html?id=${auditId}&scorecard=${scorecardId || ''}&table=${tableName || ''}`;
}

function formatTimestamp(timestamp) {
  if (!timestamp) return 'N/A';
  
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now - date;
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  
  if (diffDays === 0) {
    return 'Today ' + date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  } else if (diffDays === 1) {
    return 'Yesterday';
  } else if (diffDays < 7) {
    return date.toLocaleDateString('en-US', { weekday: 'long' });
  } else {
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
}

function getStatusText(status, isAgentView = false) {
  if (isAgentView) {
    // For agents, show status from their perspective
    const statusMap = {
      'pending': 'audit assigned',
      'in_progress': 'audit in progress',
      'completed': 'audit completed'
    };
    return statusMap[status] || 'updated';
  } else {
    // For auditors, show status from their perspective
    const statusMap = {
      'pending': 'was assigned',
      'in_progress': 'started',
      'completed': 'completed'
    };
    return statusMap[status] || 'updated';
  }
}

function getInitials(name) {
  if (!name) return '?';
  return name.split(' ').map(n => n.charAt(0)).join('').toUpperCase().slice(0, 2);
}

function escapeHtml(text) {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function getAcknowledgmentStatusChip(audit) {
  const acknowledgementStatus = audit.acknowledgement_status || audit.acknowledgementStatus || '';
  
  // Check if acknowledged
  const isAcknowledged = acknowledgementStatus && (
    acknowledgementStatus.toLowerCase().includes('acknowledged') || 
    acknowledgementStatus === 'Acknowledged'
  );
  
  // Check if pending
  const isPending = acknowledgementStatus && (
    acknowledgementStatus.toLowerCase() === 'pending' || 
    acknowledgementStatus === 'Pending'
  );
  
  // If no status or empty, default to pending (since audits are created with pending by default)
  if (!acknowledgementStatus || acknowledgementStatus.trim() === '') {
    return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: #fef3c7; color: #92400e;">
      <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      Acknowledgement Pending
    </span>`;
  }
  
  if (isAcknowledged) {
    return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: #dcfce7; color: #166534;">
      <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
      </svg>
      Acknowledged
    </span>`;
  }
  
  if (isPending) {
    return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: #fef3c7; color: #92400e;">
      <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      Acknowledgement Pending
    </span>`;
  }
  
  // Default: show pending if status is unknown
  return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: #fef3c7; color: #92400e;">
    <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
    </svg>
    Acknowledgement Pending
  </span>`;
}

function getReversalStatusChip(audit) {
  // Check if audit has reversal request
  const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
  const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
  const reversalApproved = audit.reversal_approved;
  const acknowledgementStatus = audit.acknowledgement_status || audit.acknowledgementStatus;
  
  // If no reversal was requested, return empty
  if (!reversalRequestedAt) return '';
  
  // Determine status - reversal_status column doesn't exist, use reversal_approved
  let status = null;
  
  // Check acknowledgement first
  if (acknowledgementStatus === 'Acknowledged') {
    status = 'Acknowledged';
  } 
  // If reversal was requested but not responded to yet
  else if (reversalRequestedAt && !reversalRespondedAt) {
    status = 'Pending';
  }
  // If reversal was responded to, check approval status
  else if (reversalRespondedAt) {
    // Handle different possible formats for reversal_approved
    if (reversalApproved === true || reversalApproved === 'true' || reversalApproved === 1 || reversalApproved === '1') {
      status = 'Approved';
    } else if (reversalApproved === false || reversalApproved === 'false' || reversalApproved === 0 || reversalApproved === '0') {
      status = 'Rejected';
    } else {
      // If responded but approval status unclear, default to Pending
      status = 'Pending';
    }
  }
  
  // If no status determined, return empty string
  if (!status) return '';
  
  // Determine chip styling based on status
  let statusBgColor, statusTextColor, statusIcon;
  if (status === 'Pending') {
    statusBgColor = '#fef3c7';
    statusTextColor = '#92400e';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
    </svg>`;
    statusText = 'Pending';
  } else if (status === 'Approved') {
    statusBgColor = '#dcfce7';
    statusTextColor = '#166534';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
    </svg>`;
    statusText = 'Approved';
  } else if (status === 'Rejected') {
    statusBgColor = '#fee2e2';
    statusTextColor = '#991b1b';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
    </svg>`;
    statusText = 'Rejected';
  } else if (status === 'Acknowledged') {
    statusBgColor = '#dbeafe';
    statusTextColor = '#1e40af';
    statusIcon = `<svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
    </svg>`;
    statusText = 'Acknowledged';
  } else {
    statusBgColor = '#f3f4f6';
    statusTextColor = '#374151';
    statusIcon = '';
    statusText = status;
  }
  
  return `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] font-semibold" style="background-color: ${statusBgColor}; color: ${statusTextColor};">
    ${statusIcon}
    ${statusText}
  </span>`;
}

// Notifications
async function loadNotifications() {
  try {
    if (!currentUserEmail) return;

    const cacheKey = getCacheKey('notifications', currentUserEmail, null);
    
    // Check cache first and render immediately
    const cachedNotifications = getCachedData(cacheKey);
    if (cachedNotifications) {
      console.log('Rendering cached notifications immediately');
      notifications = cachedNotifications.notifications;
      unreadNotificationCount = cachedNotifications.unreadNotificationCount;
      renderNotifications();
      updateNotificationBadge();
    }
    
    // Always fetch fresh data in background
    fetchAndCacheNotifications(cacheKey);
  } catch (error) {
    console.error('Error loading notifications:', error);
  }
}

async function fetchAndCacheNotifications(cacheKey) {
  try {
    if (!currentUserEmail) return;

    // Get recent audit assignments updates from audit tables
    // Filter by employee_email if agent, otherwise by auditor_email
    const notificationFilterField = isAgent ? 'employee_email' : 'auditor_email';
    
    const { data: scorecards, error: scError } = await window.supabaseClient
      .from('scorecards')
      .select('table_name')
      .eq('is_active', true);
    
    let assignments = [];
    if (!scError && scorecards) {
      const assignmentPromises = scorecards.map(async (scorecard) => {
        try {
          const { data: audits, error } = await window.supabaseClient
            .from(scorecard.table_name)
            .select('*')
            .eq(notificationFilterField, currentUserEmail)
            .in('audit_status', ['pending', 'in_progress', 'completed'])
            .order('assignment_created_at', { ascending: false })
            .limit(20);
          
          if (!error && audits) {
            return audits.map(audit => ({
              ...audit,
              status: audit.audit_status,
              created_at: audit.assignment_created_at || audit.created_at,
              completed_at: audit.completed_at || (audit.audit_status === 'completed' ? audit.submitted_at : null)
            }));
          }
          return [];
        } catch (err) {
          console.warn(`Error loading from ${scorecard.table_name}:`, err);
          return [];
        }
      });
      
      const assignmentResults = await Promise.all(assignmentPromises);
      assignments = assignmentResults.flat();
    }

    // Get reversals (audits with reversal requests)
    const { data: reversalScorecards, error: reversalScError } = await window.supabaseClient
      .from('scorecards')
      .select('table_name')
      .eq('is_active', true);

    let reversals = [];
    if (!reversalScError && reversalScorecards) {
      // Filter by employee_email if agent, otherwise by auditor_email
      const reversalNotificationFilterField = isAgent ? 'employee_email' : 'auditor_email';
      const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
      
      for (const scorecard of reversalScorecards) {
        try {
          // Get all reversals and filter client-side for case-insensitive matching
          const { data: auditReversals, error } = await window.supabaseClient
            .from(scorecard.table_name)
            .select('id, employee_name, employee_email, auditor_email, reversal_requested_at, reversal_responded_at, reversal_approved, reversal_status, acknowledgement_status, interaction_id, interactionId, submitted_at')
            .not('reversal_requested_at', 'is', null)
            .order('reversal_requested_at', { ascending: false })
            .limit(200);

          if (!error && auditReversals && auditReversals.length > 0) {
            // Filter reversals by email (case-insensitive)
            let filteredReversals = auditReversals.filter(rev => {
              const emailToCheck = rev[reversalNotificationFilterField];
              if (!emailToCheck) return false;
              return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
            });
            
            // Apply the same filtering logic as reversal.html
            if (isAgent) {
              // For agents: Show reversals that need acknowledgement
              filteredReversals = filteredReversals.filter(reversal => {
                const acknowledgementStatus = reversal.acknowledgement_status || reversal.acknowledgementStatus || '';
                const isAcknowledged = acknowledgementStatus && (
                  acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                  acknowledgementStatus === 'Acknowledged'
                );
                
                const isPending = reversal.reversal_approved === null;
                const isApproved = reversal.reversal_approved === true || reversal.reversal_approved === 'true' || reversal.reversal_approved === 1 || reversal.reversal_approved === '1';
                const isRejected = reversal.reversal_approved === false || reversal.reversal_approved === 'false' || reversal.reversal_approved === 0 || reversal.reversal_approved === '0';
                
                return !isAcknowledged && (isPending || isApproved || isRejected);
              });
            } else {
              // For auditors: Only show unprocessed reversals (reversal_approved is null)
              filteredReversals = filteredReversals.filter(rev => rev.reversal_approved === null);
            }
            
            // Sort reversals: prioritize those with recent responses
            filteredReversals.sort((a, b) => {
              const aResponded = a.reversal_responded_at ? new Date(a.reversal_responded_at).getTime() : 0;
              const bResponded = b.reversal_responded_at ? new Date(b.reversal_responded_at).getTime() : 0;
              if (aResponded !== bResponded) {
                return bResponded - aResponded; // Most recent responses first
              }
              const aRequested = new Date(a.reversal_requested_at).getTime();
              const bRequested = new Date(b.reversal_requested_at).getTime();
              return bRequested - aRequested;
            });
            
            filteredReversals.forEach(rev => {
              // Determine reversal status - check if it's been responded to first, then check acknowledgement
              const acknowledgementStatus = rev.acknowledgement_status || rev.acknowledgementStatus;
              const isAcknowledged = acknowledgementStatus && (
                acknowledgementStatus.toLowerCase().includes('acknowledged') || 
                acknowledgementStatus === 'Acknowledged'
              );
              
              let status = null;
              
              // Use reversal_status column if available (newer format)
              if (rev.reversal_status && rev.reversal_status !== 'Pending') {
                status = rev.reversal_status;
              }
              // If reversal was responded to, check approval status (fallback for older data)
              else if (rev.reversal_responded_at) {
                const approved = rev.reversal_approved;
                if (approved === true || approved === 'true' || approved === 1 || approved === '1') {
                  status = 'Approved';
                } else if (approved === false || approved === 'false' || approved === 0 || approved === '0') {
                  status = 'Rejected';
                } else {
                  status = 'Pending';
                }
              }
              // If reversal was requested but not responded to yet
              else if (rev.reversal_requested_at && !rev.reversal_responded_at) {
                status = 'Pending';
              }
              
              // For agents: Add notifications for all reversals that appear in reversal.html
              // For auditors: Only add notifications for unprocessed reversals (already filtered above)
              
              // Add notification for reversal request (for pending reversals)
              if (status === 'Pending') {
              reversals.push({
              ...rev,
              type: 'reversal',
                reversal_status: status,
              scorecard_table: scorecard.table_name
              });
              }
              
              // Add notification for status update if status is Approved or Rejected but NOT yet acknowledged
              if (status && (status === 'Approved' || status === 'Rejected') && !isAcknowledged) {
                const statusText = status === 'Approved' ? 'approved' : 'rejected';
                reversals.push({
                  ...rev,
                  type: 'reversal_status_update',
                  reversal_status: status,
                  status_text: statusText,
                  timestamp: rev.reversal_responded_at || rev.reversal_requested_at,
                  scorecard_table: scorecard.table_name
                });
              }
            });
          }
        } catch (err) {
          console.warn(`Error loading reversals from ${scorecard.table_name}:`, err);
        }
      }
    }

    // Combine and format notifications
    notifications = [];

    // Add assignment updates
    (assignments || []).forEach(assignment => {
      const employee = allUsers.find(u => u.email === assignment.employee_email);
      const employeeName = employee?.name || assignment.employee_name || assignment.employee_email?.split('@')[0] || 'Unknown';
      
      notifications.push({
        id: `assignment-${assignment.id}`,
        type: 'assignment',
        title: `Audit ${assignment.status === 'completed' ? 'completed' : assignment.status === 'in_progress' ? 'started' : 'assigned'}`,
        message: `${employeeName} - ${assignment.employee_name || 'Audit'}`,
        timestamp: assignment.created_at,
        status: assignment.status,
        assignmentId: assignment.id
      });
    });

    // Add reversal notifications
    reversals.forEach(reversal => {
      if (reversal.type === 'reversal_status_update') {
        // Status update notification
        const statusDisplay = reversal.reversal_status === 'Approved' ? 'Approved' : reversal.reversal_status === 'Rejected' ? 'Rejected' : reversal.reversal_status === 'Acknowledged' ? 'Acknowledged' : 'Updated';
        const interactionId = reversal.interaction_id || reversal.interactionId || '';
        notifications.push({
          id: `reversal-status-${reversal.id}`,
          type: 'reversal_status_update',
          title: `Reversal ${statusDisplay}`,
          message: isAgent 
            ? `Your reversal request has been ${reversal.status_text || 'updated'}`
            : `Reversal request${interactionId ? ` for ${interactionId}` : ''} has been ${reversal.status_text || 'updated'}`,
          timestamp: reversal.timestamp || reversal.reversal_responded_at,
          auditId: reversal.id,
          tableName: reversal.scorecard_table,
          status: reversal.reversal_status
        });
      } else {
        // Initial reversal request notification
      notifications.push({
        id: `reversal-${reversal.id}`,
        type: 'reversal',
        title: 'Reversal Requested',
        message: `${reversal.employee_name || reversal.employee_email || 'Audit'} - Reversal requested`,
        timestamp: reversal.reversal_requested_at,
        auditId: reversal.id,
        tableName: reversal.scorecard_table
      });
      }
    });

    // Sort by timestamp (most recent first)
    notifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Limit to 20 most recent
    notifications = notifications.slice(0, 20);

    // Count unread notifications (last 7 days)
    // For agents, prioritize reversal status updates
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const recentNotifications = notifications.filter(n => new Date(n.timestamp) >= sevenDaysAgo);
    
    if (isAgent) {
      // For agents, count reversal status updates separately
      const reversalStatusUpdates = recentNotifications.filter(n => n.type === 'reversal_status_update');
      unreadNotificationCount = reversalStatusUpdates.length > 0 ? reversalStatusUpdates.length : recentNotifications.length;
    } else {
      unreadNotificationCount = recentNotifications.length;
    }

    // Cache the fresh data
    setCachedData(cacheKey, {
      notifications,
      unreadNotificationCount
    });
    
    // Update UI with fresh data
    console.log('Updating UI with fresh notifications');
    renderNotifications();
    updateNotificationBadge();

  } catch (error) {
    console.error('Error loading notifications:', error);
    document.getElementById('notificationsList').innerHTML = `
      <div class="px-4 py-8 text-center text-red-500 text-xs">
        <p>Error loading notifications</p>
      </div>
    `;
  }
}

function renderNotifications() {
  const list = document.getElementById('notificationsList');
  if (!list) return;

  if (notifications.length === 0) {
    list.innerHTML = `
      <div class="px-4 py-8 text-center text-gray-500 text-xs">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"/>
        </svg>
        <p class="font-medium text-gray-700 mb-1">No notifications</p>
        <p class="text-gray-500">You're all caught up!</p>
    </div>
    `;
    return;
  }

  list.innerHTML = notifications.map(notification => {
    const timestamp = formatTimestamp(notification.timestamp);
    let iconColor, bgColor;
    
    if (notification.type === 'reversal_status_update') {
      // Color based on status
      if (notification.status === 'Approved') {
        iconColor = 'text-success';
        bgColor = 'bg-success/10';
      } else if (notification.status === 'Rejected') {
        iconColor = 'text-error';
        bgColor = 'bg-error/10';
      } else if (notification.status === 'Acknowledged') {
        iconColor = 'text-primary';
        bgColor = 'bg-primary/10';
      } else {
        iconColor = 'text-warning';
        bgColor = 'bg-warning/10';
      }
    } else if (notification.type === 'reversal') {
      iconColor = 'text-warning';
      bgColor = 'bg-warning/10';
    } else {
      iconColor = 'text-primary';
      bgColor = 'bg-primary/10';
    }

    let iconPath = '';
    if (notification.type === 'reversal_status_update') {
      if (notification.status === 'Approved') {
        iconPath = 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z';
      } else if (notification.status === 'Rejected') {
        iconPath = 'M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z';
      } else {
        iconPath = 'M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z';
      }
    } else if (notification.type === 'reversal') {
      iconPath = 'M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z';
    } else if (notification.status === 'completed') {
      iconPath = 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z';
    } else if (notification.status === 'in_progress') {
      iconPath = 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z';
    } else {
      iconPath = 'M12 6v6m0 0v6m0-6h6m-6 0H6';
    }

    return `
      <div class="px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer" onclick="handleNotificationClick('${notification.id}')">
        <div class="flex items-start gap-3">
          <div class="w-8 h-8 rounded-full ${bgColor} flex items-center justify-center flex-shrink-0">
            <svg class="w-4 h-4 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${iconPath}"/>
            </svg>
          </div>
          <div class="flex-1 min-w-0">
            <p class="text-xs font-semibold text-gray-900 mb-0.5">${escapeHtml(notification.title)}</p>
            <p class="text-xs text-gray-600 mb-1">${escapeHtml(notification.message)}</p>
            <p class="text-[10px] text-gray-500">${timestamp}</p>
          </div>
        </div>
    </div>
    `;
  }).join('');
}

function updateNotificationBadge() {
  const badge = document.getElementById('notificationBadge');
  if (!badge) return;

  if (unreadNotificationCount > 0) {
    badge.style.display = 'block';
    badge.textContent = unreadNotificationCount > 9 ? '9+' : unreadNotificationCount;
    badge.className = 'absolute top-0 right-0 w-5 h-5 bg-error rounded-full text-white text-[10px] font-semibold flex items-center justify-center';
  } else {
    badge.style.display = 'none';
  }
}

function showNotifications() {
  const modal = document.getElementById('notificationsModal');
  if (!modal) return;
  
  // Load notifications when showing
  loadNotifications();
  modal.classList.remove('opacity-0', 'invisible');
  modal.classList.add('opacity-100', 'visible');
}

function hideNotifications() {
  const modal = document.getElementById('notificationsModal');
  if (!modal) return;
  
  modal.classList.remove('opacity-100', 'visible');
  modal.classList.add('opacity-0', 'invisible');
}

// Show notifications on hover
document.addEventListener('DOMContentLoaded', function() {
  const notificationBtn = document.getElementById('notificationBtn');
  const notificationModal = document.getElementById('notificationsModal');
  
  if (notificationBtn && notificationModal) {
    let hoverTimeout;
    
    notificationBtn.addEventListener('mouseenter', function() {
      clearTimeout(hoverTimeout);
      showNotifications();
    });
    
    notificationBtn.addEventListener('mouseleave', function(e) {
      // Check if mouse is moving to modal
      const relatedTarget = e.relatedTarget;
      if (notificationModal.contains(relatedTarget)) {
        return; // Don't hide if moving to modal
      }
      
      hoverTimeout = setTimeout(() => {
        hideNotifications();
      }, 200); // Small delay to allow moving to modal
    });
    
    notificationModal.addEventListener('mouseenter', function() {
      clearTimeout(hoverTimeout);
    });
    
    notificationModal.addEventListener('mouseleave', function() {
      hideNotifications();
    });
  }
});

function handleNotificationClick(notificationId) {
  const notification = notifications.find(n => n.id === notificationId);
  if (!notification) return;

  // Hide modal
  hideNotifications();

  // Navigate based on type
  if (notification.type === 'assignment' && notification.assignmentId) {
    viewAudit(notification.assignmentId);
  } else if ((notification.type === 'reversal' || notification.type === 'reversal_status_update') && notification.auditId && notification.tableName) {
    // Navigate to audit view for reversal
    window.location.href = `audit-view.html?id=${notification.auditId}&table=${notification.tableName}`;
  }
}
</script>
</body>
</html>