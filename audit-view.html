<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Audit Details | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="intercom-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="search.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f9fafb;
        }
        
        .full-width-container {
            width: 100%;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }
        
    </style>
</head>

<body>
<!-- Full screen layout without sidebar -->
<div class="full-width-container">

    <!-- Reversal Request Form (hidden by default) -->
    <div id="reversalFormContainer" class="no-print" style="display: none; background: #fff3cd; border: 0.0703rem solid #ffc107; border-radius: 0.375rem; padding: 0.75rem; margin: 1.125rem; box-shadow: 0 0.0703rem 0.2812rem rgba(0,0,0,0.1);">
        <div style="display: flex; align-items: center; gap: 0.375rem; margin-bottom: 0.5625rem;">
            <svg style="width: 0.9375rem; height: 0.9375rem; color: #f59e0b;" viewBox="0 0 24 24" fill="currentColor">
                <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
            </svg>
            <h3 style="margin: 0; font-size: 0.75rem; font-weight: 700; color: #b45309; font-family: 'Poppins', sans-serif;">Submit Reversal Request</h3>
        </div>
        
        <p style="font-size: 0.6094rem; color: #92400e; margin-bottom: 0.75rem; line-height: 1.5; font-family: 'Poppins', sans-serif;">
            If you believe this audit contains errors or inaccuracies, please add comments to the parameters using the comment icon next to each parameter's feedback, then select the affected parameters below.
        </p>
        
        <form id="reversalForm" style="display: grid; gap: 0.5625rem;">
            <!-- Two-column grid for compact layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5625rem;">
                <!-- Reversal Type -->
                <div>
                    <label for="reversalType" style="display: block; font-size: 0.5625rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                        Reversal Type <span style="color: #ef4444;">*</span>
                    </label>
                    <select id="reversalType" required style="width: 100%; padding: 0.375rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: white;">
                        <option value="">Select type...</option>
                        <option value="Clarification Requested">Clarification Requested</option>
                        <option value="Revision Requested">Revision Requested</option>
                    </select>
                </div>
                
                <!-- Reversal Reason Dropdown -->
                <div>
                    <label for="reversalReasonDropdown" style="display: block; font-size: 0.5625rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                        Reversal Reason <span style="color: #ef4444;">*</span>
                    </label>
                    <select id="reversalReasonDropdown" required style="width: 100%; padding: 0.375rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: white;">
                        <option value="">Select reason...</option>
                        <option value="Error in Scoring">Error in Scoring</option>
                        <option value="Incorrect Parameter Applied">Incorrect Parameter Applied</option>
                        <option value="Misinterpretation">Misinterpretation of Interaction</option>
                        <option value="Technical Issue">Technical Issue</option>
                        <option value="Policy Clarification">Policy Clarification Needed</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
            </div>
            
            <!-- Within Auditor Scope -->
            <div style="display: flex; align-items: center; gap: 0.375rem;">
                <input type="checkbox" id="withinAuditorScope" checked style="width: 0.75rem; height: 0.75rem; cursor: pointer;">
                <label for="withinAuditorScope" style="font-size: 0.6094rem; color: #374151; font-family: 'Poppins', sans-serif; cursor: pointer;">
                    I believe this can be resolved by the original auditor
                </label>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; padding-top: 0.375rem;">
                <button type="button" onclick="toggleReversalForm()" style="padding: 0.4688rem 0.9375rem; background-color: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                    Cancel
                </button>
                <button type="submit" style="padding: 0.4688rem 0.9375rem; background-color: #ef4444; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13"/>
                        <path d="M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                    Submit Reversal Request
                </button>
            </div>
        </form>
    </div>

    <!-- Audit Content Container -->
    <div id="auditContainer" style="width: 100%; box-sizing: border-box;">
        <!-- Loading indicator -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; padding: 3rem; width: 100%;">
            <div style="text-align: center;">
                <div style="border: 0.1406rem solid #f3f4f6; border-top: 0.1406rem solid #1A733E; border-radius: 50%; width: 2.25rem; height: 2.25rem; animation: spin 1s linear infinite; margin: 0 auto 0.75rem;"></div>
                <p style="color: #6b7280; font-family: 'Poppins', sans-serif;">Loading audit details...</p>
            </div>
        </div>

        <!-- Error message -->
        <div id="errorMessage" style="display: none; text-align: center; padding: 1.5rem; color: #ef4444; font-family: 'Poppins', sans-serif; width: 100%;">
            <p style="font-size: 0.8438rem; font-weight: 600; margin-bottom: 0.375rem;">Error Loading Audit</p>
            <p id="errorText" style="font-size: 0.6562rem;"></p>
            <button onclick="window.history.back()" style="margin-top: 0.75rem; padding: 0.375rem 1.125rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer;">Go Back</button>
        </div>

        <!-- Audit content will be dynamically loaded here -->
        <div id="auditContent"></div>
    </div>

</div>
<!-- End full-width-container -->

<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes pulse-attention {
        0%, 100% { 
            opacity: 1;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.02);
        }
    }

    @keyframes spin-slow {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes flash-text {
        0%, 100% { 
            opacity: 1;
        }
        50% { 
            opacity: 0.6;
        }
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
        20%, 40%, 60%, 80% { transform: translateX(2px); }
    }


/* Chat view scrollbar styling */
#transcriptChatView::-webkit-scrollbar {
    width: 0.3234rem;
}

#transcriptChatView::-webkit-scrollbar-track {
    background: #f0f2f5;
}

#transcriptChatView::-webkit-scrollbar-thumb {
    background: #9ca3af;
    border-radius: 0.1617rem;
}

#transcriptChatView::-webkit-scrollbar-thumb:hover {
    background: #6b7280;
    }
</style>

<script>
// Global audit data
let currentAudit = null;
let currentScorecardId = null;
let currentTableName = null;
let currentErrorFields = [];
let currentUserEmail = null;

// Get current logged-in user email
function getCurrentUserEmail() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            const user = JSON.parse(userInfo);
            return user?.email || null;
        }
    } catch (error) {
        console.error('Error getting current user email:', error);
    }
    return null;
}

// Get current logged-in user info
function getCurrentUserInfo() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            return JSON.parse(userInfo);
        }
    } catch (error) {
        console.error('Error getting current user info:', error);
    }
    return null;
}

// Check if current user is the audited employee
function isCurrentUserAuditedEmployee() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditEmployeeEmail = currentAudit.employeeEmail || currentAudit.employee_email || '';
    return auditEmployeeEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is a Quality Analyst
function isCurrentUserQualityAnalyst() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    return role === 'Quality Analyst';
}

// Check if there's a pending reversal request
function hasPendingReversalRequest() {
    if (!currentAudit) {
        return false;
    }
    
    // The schema doesn't have reversal_status column
    // Status is determined by reversal_approved and reversal_responded_at
    const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
    const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
    const reversalApproved = currentAudit.reversal_approved || currentAudit.reversalApproved;
    
    // Pending if reversal was requested but not yet responded to
    if (reversalRequestedAt && !reversalRespondedAt) {
        return true;
    }
    
    // Also check if reversal_approved is null (which means pending)
    if (reversalRequestedAt && reversalApproved === null || reversalApproved === undefined) {
        return true;
    }
    
    return false;
}

// Check if edit button should be shown (only for Quality Analysts when reversal is pending)
function shouldShowEditButton() {
    return hasPendingReversalRequest() && isCurrentUserQualityAnalyst();
}

// Check if reversal button should be shown (hide after 48 hours from audit submission)
function checkIfReversalButtonShouldShow(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return true; // If no timestamp, show button (fallback)
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const diffMs = now - submissionDate;
    const diffHours = diffMs / (1000 * 60 * 60);
    
    // Hide after 48 hours
    return diffHours < 48;
}

// Get time remaining until 48 hours expires (in seconds)
function getTimeRemainingUntil48Hours(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return null;
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const expirationTime = new Date(submissionDate.getTime() + (48 * 60 * 60 * 1000)); // 48 hours
    const remainingMs = expirationTime - now;
    
    if (remainingMs <= 0) {
        return 0; // Already expired
    }
    
    return Math.floor(remainingMs / 1000); // Return seconds
}

// Format time remaining for display (always show seconds)
function formatTimeRemaining(seconds) {
    if (seconds <= 0) {
        return 'Expired';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}h ${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else {
        return `${secs}s`;
    }
}

// Handle closing/navigating away - check if acknowledgement is pending or comments without reversal
async function handleCloseAuditView() {
    // Check if user is the audited employee
    if (isCurrentUserAuditedEmployee() && currentAudit) {
        // Check if user has comments but hasn't submitted a reversal
        const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const hasComments = Object.keys(parameterComments).some(key => {
            const comment = parameterComments[key];
            if (!comment) return false;
            // Check for single comment format: {comment: "text"}
            if (comment.comment && comment.comment.trim()) return true;
            // Check for array format: {comments: ["text1", "text2"]}
            if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
            return false;
        });
        
        // Check if reversal has been submitted (check both camelCase and snake_case)
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        const hasSubmittedReversal = !!reversalRequestedAt;
        
        // If user has comments but hasn't submitted reversal, prevent navigation
        // Only check if reversal hasn't been submitted yet
        if (hasComments && !hasSubmittedReversal) {
            // Wait for confirmation dialog to be available
            if (!window.confirmationDialog) {
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!window.confirmationDialog) {
                    alert('Warning: You have unsaved parameter comments. If you leave now, your comments will be lost. Please submit a reversal request to save them.');
                    return false; // Prevent navigation
                }
            }
            
            const result = await window.confirmationDialog.show({
                title: '⚠ Unsaved Comments',
                message: 'You have added parameter comments but haven\'t submitted a reversal request yet. If you leave now, your comments will be lost (they are only saved when you submit a reversal request).\n\nPlease submit a reversal request to save your comments before leaving.',
                confirmText: 'Submit Reversal',
                cancelText: 'Leave Anyway (Comments will be lost)'
            });
            
            if (result) {
                // User wants to submit reversal - open the reversal form
                toggleReversalForm();
                return false; // Prevent navigation
            } else {
                // User chose to leave anyway - they understand comments will be lost
                // Allow navigation but warn them one more time
                const confirmLeave = confirm('Are you sure you want to leave? Your parameter comments have not been saved and will be lost.');
                if (!confirmLeave) {
                    return false; // User changed their mind
                }
                
                // Clear comments from local object (comments are only stored locally until reversal submission)
                if (currentAudit) {
                    currentAudit.parameterComments = {};
                    currentAudit.parameter_comments = {};
                }
                
                return true; // Allow navigation
            }
        }
        
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
        
        // Determine reversal status
        const reversalRespondedAt = currentAudit.reversalRespondedAt || currentAudit.reversal_responded_at;
        const reversalStatus = reversalRequestedAt && !reversalRespondedAt ? 'Pending' : 
                              (currentAudit.reversalApproved === true || currentAudit.reversal_approved === true) ? 'Approved' :
                              (currentAudit.reversalApproved === false || currentAudit.reversal_approved === false) ? 'Rejected' : null;
        
        // If a reversal is pending, user cannot acknowledge - allow navigation without showing modal
        if (reversalStatus === 'Pending') {
            return true; // Allow navigation
        }
        
        // If acknowledgement is pending (not acknowledged) and no reversal is pending, show the same confirmation as acknowledge button
        if (acknowledgementStatusLower !== 'acknowledged') {
            // Use the same confirmation dialog that appears when clicking acknowledge button
            // Create a wrapper that tracks success and shows the same confirmation
            const acknowledgeWithNavigation = async () => {
                try {
                    // Verify that current user is the audited employee
                    if (!isCurrentUserAuditedEmployee()) {
                        return false;
                    }
                    
                    // Wait for confirmation dialog to be available
                    if (!window.confirmationDialog) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.confirmationDialog) {
                            alert('Error: Confirmation dialog not available. Please refresh the page.');
                            return false;
                        }
                    }
                    
                    // Show the same confirmation dialog as the acknowledge button
                    const result = await window.confirmationDialog.show({
                        title: 'Acknowledge Audit',
                        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
                        confirmText: 'Acknowledge',
                        cancelText: 'Cancel'
                    });
                    
                    if (!result) {
                        return false; // User cancelled
                    }
                    
                    if (!currentAudit || !currentTableName) {
                        alert('Error: Audit data not available');
                        return false;
                    }
                    
                    // Record acknowledgment in the database
                    const acknowledgementTime = new Date().toISOString();
                    const { data, error } = await window.supabaseClient
                        .from(currentTableName)
                        .update({
                            acknowledgement_status: 'Acknowledged',
                            acknowledgement_status_updated_at: acknowledgementTime
                        })
                        .eq('id', currentAudit.id)
                        .select();
                    
                    if (error) throw error;
                    
                    // Show success message
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Success',
                            message: '✓ Audit acknowledged. Thank you for your confirmation.',
                            confirmText: 'OK',
                            type: 'success'
                        });
                    } else {
                        alert('✓ Audit acknowledged. Thank you for your confirmation.');
                    }
                    
                    // Update currentAudit to reflect acknowledgement
                    if (currentAudit) {
                        currentAudit.acknowledgementStatus = 'Acknowledged';
                        currentAudit.acknowledgement_status = 'Acknowledged';
                        currentAudit.acknowledgementStatusUpdatedAt = acknowledgementTime;
                        currentAudit.acknowledgement_status_updated_at = acknowledgementTime;
                    }
                    
                    return true; // Success
                    
                } catch (error) {
                    console.error('Error acknowledging audit:', error);
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to record acknowledgment. Please try again.',
                            confirmText: 'OK',
                            type: 'error'
                        });
                    } else {
                        alert('Failed to record acknowledgment. Please try again.');
                    }
                    return false;
                }
            };
            
            // Call the acknowledge function
            acknowledgementSuccessful = await acknowledgeWithNavigation();
            
            // If acknowledgement was successful, allow navigation
            // If user cancelled, prevent navigation
            return acknowledgementSuccessful;
        }
    }
    
    // If no acknowledgement pending or not the audited employee, allow navigation
    return true;
}

// Load audit on page load
document.addEventListener('DOMContentLoaded', async function() {
    try {
        // Get current user email first
        currentUserEmail = getCurrentUserEmail();
        
        await loadAuditFromURL();
        
        // Add escape key listener - check acknowledgement before closing
        document.addEventListener('keydown', async function(event) {
            if (event.key === 'Escape') {
                event.preventDefault(); // Prevent default escape behavior
                const canNavigate = await handleCloseAuditView();
                if (canNavigate) {
                    window.location.href = 'expert-audits.html';
                }
            }
        });
        
        // Prevent browser close/refresh when user has unsaved comments
        window.addEventListener('beforeunload', function(event) {
            if (isCurrentUserAuditedEmployee() && currentAudit) {
                const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
                const hasComments = Object.keys(parameterComments).some(key => {
                    const comment = parameterComments[key];
                    if (!comment) return false;
                    // Check for single comment format: {comment: "text"}
                    if (comment.comment && comment.comment.trim()) return true;
                    // Check for array format: {comments: ["text1", "text2"]}
                    if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
                    return false;
                });
                
                const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                const hasSubmittedReversal = !!reversalRequestedAt;
                
                // If user has comments but hasn't submitted reversal, prevent page unload
                if (hasComments && !hasSubmittedReversal) {
                    // Modern browsers ignore custom messages, but we still need to set returnValue
                    event.preventDefault();
                    event.returnValue = 'You have unsaved parameter comments. If you leave now, your comments will be lost (they are only saved when you submit a reversal request).';
                    return event.returnValue;
                }
            }
        });
    } catch (error) {
        console.error('Error loading audit:', error);
        showError('Failed to load audit: ' + error.message);
    }
});

// Load audit from URL parameters
async function loadAuditFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');

    if (!auditId || !tableName) {
        showError('Invalid URL parameters. Missing audit ID or table name.');
        return;
    }

    currentTableName = tableName;

    try {
        // Wait for Supabase to initialize
        let attempts = 0;
        const maxAttempts = 50;
        while (!window.supabaseClient && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            throw new Error('Supabase client not initialized');
        }

        // Load audit data
        // Try to get the audit - if .single() fails, check if it's because no results were found
        let data, error;
        const result = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId);
        
        if (result.error) {
            error = result.error;
            data = null;
        } else if (result.data && result.data.length === 0) {
            // No results found
            error = { message: `Audit with ID "${auditId}" not found in table "${tableName}"` };
            data = null;
        } else if (result.data && result.data.length === 1) {
            // Exactly one result - success
            data = result.data[0];
            error = null;
        } else if (result.data && result.data.length > 1) {
            // Multiple results - use first one but log warning
            console.warn(`Multiple audits found with ID "${auditId}" in table "${tableName}". Using first result.`);
            data = result.data[0];
            error = null;
        } else {
            error = { message: 'Unknown error loading audit' };
            data = null;
        }

        if (error) throw error;
        if (!data) throw new Error('Audit not found');

        currentAudit = data;
        
        // Get scorecard ID from URL parameter, or try to get it from audit data or table name
        let finalScorecardId = scorecardId;
        
        // If not in URL, try to get from audit data
        if (!finalScorecardId && data.scorecard_id) {
            finalScorecardId = data.scorecard_id;
        }
        
        // If still not found, try to find scorecard by matching table name
        if (!finalScorecardId && tableName) {
            try {
                const { data: scorecards, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('id')
                    .eq('table_name', tableName)
                    .limit(1);
                
                if (!scorecardError && scorecards && scorecards.length > 0) {
                    finalScorecardId = scorecards[0].id;
                }
            } catch (err) {
                console.warn('Could not find scorecard by table name:', err);
            }
        }
        
        currentScorecardId = finalScorecardId;

        // Map snake_case to camelCase
        const audit = {
            ...data,
            id: data.id,
            submittedAt: data.submitted_at || data.audit_timestamp,
            auditTimestamp: data.submitted_at || data.audit_timestamp, // Using submitted_at for backward compatibility
            auditDuration: data.audit_duration,
            auditorEmail: data.auditor_email,
            auditorName: data.auditor_name,
            employeeName: data.employee_name,
            employeeEmail: data.employee_email,
            employeeType: data.employee_type,
            employeeDepartment: data.employee_department,
            interactionId: data.interaction_id,
            interactionDate: data.interaction_date,
            auditType: data.audit_type,
            channel: data.channel,
            quarter: data.quarter,
            week: data.week,
            countryOfEmployee: data.country_of_employee,
            clientEmail: data.client_email,
            agentPreStatus: data.agent_pre_status,
            agentPostStatus: data.agent_post_status,
            passingStatus: data.passing_status,
            validationStatus: data.validation_status,
            averageScore: data.average_score,
            criticalErrors: data.critical_errors,
            totalErrorsCount: data.total_errors_count,
            transcript: data.transcript,
            errorDescription: data.error_description,
            criticalFailError: data.critical_fail_error,
            criticalError: data.critical_error,
            significantError: data.significant_error,
            recommendations: data.recommendations,
            // Reversal tracking fields
            reversalRequestedAt: data.reversal_requested_at,
            reversalRespondedAt: data.reversal_responded_at,
            reversalStatus: data.reversal_status, // Map reversal_status
            slaInHours: data.sla_in_hours,
            reasonForReversalResponseDelay: data.reason_for_reversal_response_delay,
            reversalApproved: data.reversal_approved,
            withinAuditorScope: data.within_auditor_scope,
            scoreBeforeAppeal: data.score_before_appeal,
            scoreAfterAppeal: data.score_after_appeal,
            didResultInPass: data.did_result_in_pass,
            reversalType: data.reversal_type,
            reversalMetricsParameters: data.reversal_metrics_parameters,
            reversalJustificationFromAgent: data.reversal_justification_from_agent,
            reversalAttachments: data.reversal_attachments,
            reversalApprovedBy: data.reversal_approved_by,
            reversalResolvedBy: data.reversal_resolved_by,
            // Acknowledgement tracking fields
            acknowledgementStatus: data.acknowledgement_status,
            acknowledgementStatusUpdatedAt: data.acknowledgement_status_updated_at,
            // Parameter comments
            parameterComments: data.parameter_comments || {},
            parameter_comments: data.parameter_comments || {},
            _scorecard_id: finalScorecardId,
            scorecardId: finalScorecardId,
            scorecard_id: finalScorecardId,
            _scorecard_table: tableName
        };

        // Load scorecard parameters
        let errorFields = [];
        let auditScorecard = null;

        if (finalScorecardId) {
            try {
                // Load scorecard info
                const { data: scorecardData, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('*')
                    .eq('id', finalScorecardId)
                    .single();

                if (!scorecardError && scorecardData) {
                    auditScorecard = scorecardData;
                }

                // Load parameters
                const { data: parameters, error: paramsError } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .select('*')
                    .eq('scorecard_id', finalScorecardId)
                    .eq('is_active', true)
                    .order('display_order', { ascending: true });

                if (!paramsError && parameters) {
                    errorFields = parameters.map(param => ({
                        key: param.field_id,
                        label: param.error_name,
                        feedback: `feedback_${param.field_id}`,
                        severity: param.error_category.includes('Fail') ? 'Critical Fail' : 
                                 param.error_category.includes('Critical') ? 'Critical' : 
                                 'Significant',
                        field_type: param.field_type || 'counter',
                        parameter_type: param.parameter_type || 'error',
                        points: param.penalty_points || 0
                    }));
                }
            } catch (err) {
                console.error('Error loading scorecard parameters:', err);
            }
        }

        // Store errorFields globally for reversal form
        currentErrorFields = errorFields;

        // Render the audit
        renderAudit(audit, auditScorecard, errorFields);

        // Hide loading indicator
        document.getElementById('loadingIndicator').style.display = 'none';

    } catch (error) {
        console.error('Error loading audit:', error);
        showError(error.message);
    }
}

// Show error message
function showError(message) {
    document.getElementById('loadingIndicator').style.display = 'none';
    document.getElementById('errorMessage').style.display = 'block';
    document.getElementById('errorText').textContent = message;
}

// Edit current audit
function editCurrentAudit() {
    // Verify that current user is a Quality Analyst and there's a pending reversal
    if (!shouldShowEditButton()) {
        alert('Error: You can only edit audits with pending reversal requests.');
        return;
    }
    
    if (!currentAudit || !currentScorecardId || !currentTableName) {
        alert('Cannot edit audit: missing required data');
        return;
    }
    window.location.href = `edit-audit.html?id=${currentAudit.id}&scorecard=${currentScorecardId}&table=${currentTableName}`;
}

// Generate error details HTML
function generateErrorDetails(audit, errorFields) {
    // Calculate actual totals from individual error counts
    let criticalFailTotal = 0;
    let criticalTotal = 0;
    let significantTotal = 0;
    
    errorFields.forEach(field => {
        const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
        if (count > 0) {
            if (field.severity === 'Critical Fail') {
                criticalFailTotal += count;
            } else if (field.severity === 'Critical') {
                criticalTotal += count;
            } else if (field.severity === 'Significant') {
                significantTotal += count;
            }
        }
    });
    
    // Determine column header based on field types
    let statusColumnHeader = 'Status';
    if (errorFields.length > 0) {
        const allCounters = errorFields.every(field => field.field_type === 'counter');
        const allRadio = errorFields.every(field => field.field_type === 'radio');
        
        if (allCounters) {
            statusColumnHeader = 'Counts';
        } else if (allRadio) {
            statusColumnHeader = 'Achieved?';
        }
    }
    
    // Check if current user is the audited employee (for showing comment boxes)
    const isAuditedEmployee = isCurrentUserAuditedEmployee();
    
    // Check if reversal has been submitted (disable inputs if so)
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    const hasReversalSubmitted = !!reversalRequestedAt;
    
    // Load parameter comments from audit data
    const parameterComments = audit.parameterComments || audit.parameter_comments || {};
    
    // Check if any parameter has a comment (handle both single comment and comments array format)
    const hasAnyComments = errorFields.some(field => {
        const comment = parameterComments[field.key];
        if (!comment) return false;
        // Check for single comment format
        if (comment.comment && comment.comment.trim()) return true;
        // Check for comments array format
        if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
        return false;
    });
    
    // Get employee name and extract first name
    const employeeName = audit.employeeName || audit.employee_name || 'Employee';
    const firstName = employeeName.split(' ')[0] || employeeName;
    const commentColumnHeader = `${firstName}'s Comment`;
    
    // Show comments column if comments exist OR if audited employee (always show for audited employees)
    // Use a global variable to track if comment column should be shown
    if (typeof window.showCommentsColumn === 'undefined') {
        // For audited employees, always show the comment column by default
        window.showCommentsColumn = isAuditedEmployee || hasAnyComments;
    }
    const showCommentsColumn = window.showCommentsColumn;
    
    const errorRows = errorFields.map(field => {
        const rawValue = audit[field.key];
        let displayValue = '';
        let count = 0;
        
        if (field.field_type === 'radio') {
            // For radio buttons, show YES/NO
            const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
            displayValue = isYes ? '✓ YES' : '✗ NO';
            count = isYes ? 1 : 0;
        } else {
            // For counters, show the number
            count = rawValue ? parseInt(rawValue) : 0;
            displayValue = count.toString();
        }
        
        // Handle feedback - support both old format (string) and new format (JSON array)
        const feedbackData = audit[field.feedback];
        let feedbackArray = [];
        
        if (feedbackData) {
            if (typeof feedbackData === 'string') {
                // Try to parse as JSON array, fallback to single string
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch (e) {
                    // If not valid JSON, treat as single string (backward compatibility)
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
        }
        
        // Filter out empty feedbacks
        feedbackArray = feedbackArray.filter(f => f && f.trim());
        const hasFeedback = feedbackArray.length > 0;
        const combinedFeedback = feedbackArray.join('\n\n---\n\n'); // Combine with separator
        
        // Different colors for different parameter types
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (field.parameter_type === 'error') {
            if (field.severity === 'Critical Fail') {
                severityColor = '#ef4444';
                severityBg = '#fee2e2';
            } else if (field.severity === 'Critical') {
                severityColor = '#f59e0b';
                severityBg = '#fef3c7';
            }
        } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Get existing comments for this parameter (can have multiple comments for multiple feedbacks)
        const existingComments = parameterComments[field.key] || {};
        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
        
        // Generate comment HTML - simple input boxes for each feedback
        let commentHtml = '';
        if (showCommentsColumn) {
            // For auditors (non-audited employees), always show comments as read-only text
            // For audited employees, show input boxes (or read-only if reversal submitted)
            if (hasFeedback) {
                // Create input boxes/display for each feedback
                commentHtml = feedbackArray.map((feedbackText, index) => {
                    const existingComment = commentsArray[index] || '';
                    const commentInputId = `comment_${field.key}_${index}`;
                    return `
                        <div style="margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">
                            ${feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                            ${!isAuditedEmployee || hasReversalSubmitted ? 
                                // For auditors or after reversal submitted, show as read-only text
                                (existingComment ? 
                                    `<div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(existingComment)}</div>` :
                                    '<span style="color: #9ca3af; font-style: italic; font-size: 0.5659rem;">-</span>'
                                ) :
                                // For audited employees (before reversal), show input box
                                `<input type="text" id="${commentInputId}" data-param-key="${field.key}" data-feedback-index="${index}" value="${escapeHtml(existingComment)}" placeholder="Enter your comment..." style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif;" onchange="saveParameterComment('${field.key}', ${index}, this.value)" onblur="saveParameterComment('${field.key}', ${index}, this.value)">`
                            }
                </div>
            `;
                }).join('');
            } else {
                // No feedback for this parameter - check if there are comments anyway
                // (in case comments were added but feedback was removed, or for backward compatibility)
                if (commentsArray.length > 0 && commentsArray.some(c => c && c.trim())) {
                    // Show comments even without feedback
                    commentHtml = commentsArray.map((comment, index) => {
                        if (!comment || !comment.trim()) return '';
                        return `
                            <div style="margin-bottom: ${index < commentsArray.length - 1 ? '0.6469rem' : '0'};">
                                ${commentsArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                                <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(comment)}</div>
                            </div>
                        `;
                    }).filter(html => html).join('');
                } else {
                    // No comments and no feedback - show dash
                    commentHtml = '<span style="color: #9ca3af; font-style: italic;">-</span>';
                }
            }
        }
        
        // Generate feedback HTML - display all feedbacks (plain, no containers)
        let feedbackHtml = '-';
        if (hasFeedback) {
            // Plain display - multiple feedbacks separated by line breaks
            feedbackHtml = feedbackArray.map((feedbackText, index) => {
                const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                return `${label}<div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">${escapeHtml(feedbackText)}</div>`;
            }).join('');
        }
        
        // Build grid columns - must match header columns for proper alignment
        // For audited employees, always show comment column (persistent)
        const gridColumns = showCommentsColumn 
            ? '2fr 1fr 1fr 1fr 2fr 2.5fr' 
            : '2fr 1fr 1fr 1fr 2fr';
        
        return `
            <div style="display: grid; grid-template-columns: ${gridColumns}; gap: 0.6469rem; align-items: start; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6; width: 100%; min-width: 0;">
                <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                    ${field.label}
                </div>
                <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                    ${field.points}
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${(field.parameter_type === 'achievement' || field.parameter_type === 'bonus') && field.field_type !== 'radio' ? 'ACHIEVEMENT' : field.severity}</span>
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>
                </div>
                <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                    ${feedbackHtml}
                </div>
                ${showCommentsColumn ? `
                    <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                        ${commentHtml || '<span style="color: #9ca3af; font-style: italic;">-</span>'}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    return `
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    Error Details
                </h3>
                <div style="display: flex; gap: 0.2425rem;">
                    <span style="background: #dc2626; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical Fail: ${criticalFailTotal}</span>
                    <span style="background: #f59e0b; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical: ${criticalTotal}</span>
                    <span style="background: #3b82f6; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Significant: ${significantTotal}</span>
                </div>
            </div>
            
            <div style="background: white; border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                <div style="background-color: #f8f9fa; padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid #e5e7eb;">
                    <div style="display: grid; grid-template-columns: ${showCommentsColumn ? '2fr 1fr 1fr 1fr 2fr 2.5fr' : '2fr 1fr 1fr 1fr 2fr'}; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                        <div style="min-width: 0;">Error Type</div>
                        <div style="text-align: center; min-width: 0;">Points</div>
                        <div style="text-align: center; min-width: 0;">Severity</div>
                        <div style="text-align: center; min-width: 0;">${statusColumnHeader}</div>
                        <div style="min-width: 0;">Feedback</div>
                        ${showCommentsColumn ? 
                            `<div style="min-width: 0;">${escapeHtml(commentColumnHeader)}</div>` : 
                            ''
                        }
                    </div>
                </div>
                <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                    ${errorRows}
                </div>
                </div>
            </div>
            
        <!-- Avg Score, Passing Status & Post-Status -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.averageScore || '0'}%</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                    <div style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.passingStatus || 'N/A'}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Post-Status</p>
                    <div style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.agentPostStatus || 'N/A'}</div>
                </div>
            </div>
        </div>

        <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.totalErrorsCount || '0'}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalFailTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${significantTotal}</div>
                </div>
            </div>
        </div>
        
        <!-- Pre/Post Status -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.6469rem; margin-bottom: 0.6469rem;">
            <div style="background: #f0fdf4; padding: 0.4852rem; border-radius: 0.2425rem; border: 0.0304rem solid #bbf7d0;">
                <p style="font-size: 0.4447rem; color: #166534; margin: 0 0 0.1617rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0122rem; font-weight: 600;">Pre-Status</p>
                <p style="font-size: 0.5659rem; color: #15803d; margin: 0; font-family: 'Poppins', sans-serif; font-weight: 600;">${audit.agentPreStatus || 'N/A'}</p>
            </div>
            <div style="background: #f0f9ff; padding: 0.4852rem; border-radius: 0.2425rem; border: 0.0304rem solid #bae6fd;">
                <p style="font-size: 0.4447rem; color: #075985; margin: 0 0 0.1617rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0122rem; font-weight: 600;">Post-Status</p>
                <p style="font-size: 0.5659rem; color: #0369a1; margin: 0; font-family: 'Poppins', sans-serif; font-weight: 600;">${audit.agentPostStatus || 'N/A'}</p>
            </div>
        </div>
    `;
}

// Render audit HTML
function renderAudit(audit, auditScorecard, errorFields) {
    // Helper functions are now in audit-template.js
    // Use them from the global scope (formatDate, getCountryFlag, escapeHtml)

    // Check for passing status (handle both "Passing" and "Passed", but exclude "Not Passing")
    const passingStatus = audit.passingStatus ? audit.passingStatus.toLowerCase() : '';
    const isPassing = passingStatus && passingStatus.includes('pass') && !passingStatus.includes('not');

    const errorDetailsHtml = errorFields.length > 0 ? generateErrorDetails(audit, errorFields) : '';

    // Determine header gradient based on passing status (handle both old and new values)
    const normalizedPassingStatus = passingStatus && passingStatus.includes('not') ? 'Not Passed' : 'Passed';
    const headerGradient = normalizedPassingStatus === 'Not Passed' 
        ? 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)' 
        : 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    
    // Use formatDate and getCountryFlag from audit-template.js
    const formatDate = window.formatDate || function(dateString, includeTime) {
        if (!dateString) return 'N/A';
        const date = new Date(dateString);
        const day = date.getDate();
        const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const month = months[date.getMonth()];
        const year = date.getFullYear();
        if (includeTime) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            return `${day} ${month} ${year}, ${hours}:${minutes} ${ampm}`;
        }
        return `${day} ${month} ${year}`;
    };
    const getCountryFlag = window.getCountryFlag || function(countryName) {
        if (!countryName) return '🏳️';
        const country = countryName.toLowerCase();
        const flagMap = {
            'bangladesh': '🇧🇩', 'india': '🇮🇳', 'pakistan': '🇵🇰', 'philippines': '🇵🇭',
            'indonesia': '🇮🇩', 'sri lanka': '🇱🇰', 'nepal': '🇳🇵', 'thailand': '🇹🇭',
            'vietnam': '🇻🇳', 'malaysia': '🇲🇾', 'singapore': '🇸🇬', 'usa': '🇺🇸',
            'united states': '🇺🇸', 'uk': '🇬🇧', 'united kingdom': '🇬🇧', 'canada': '🇨🇦',
            'australia': '🇦🇺', 'new zealand': '🇳🇿', 'south africa': '🇿🇦', 'egypt': '🇪🇬',
            'kenya': '🇰🇪', 'nigeria': '🇳🇬', 'ghana': '🇬🇭'
        };
        return flagMap[country] || '🏳️';
    };
    const escapeHtml = window.escapeHtml || function(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    };

    // Build interaction ID HTML (clickable link if available)
    // Get Intercom app ID from config (generated from environment variables)
    const INTERCOM_APP_ID = window.intercomConfig?.appId || '';
    let interactionIdHtml;
    if (audit.interactionId) {
        const interactionId = audit.interactionId;
        const intercomUrl = INTERCOM_APP_ID 
            ? `https://app.intercom.com/a/inbox/${INTERCOM_APP_ID}/inbox/conversation/${interactionId}?view`
            : '#';
        interactionIdHtml = '<a href="' + escapeHtml(intercomUrl) + '" target="_blank" rel="noopener noreferrer" style="font-size: 0.4852rem; color: #1A733E; font-family: \'Poppins\', sans-serif; font-weight: 600; text-decoration: underline; cursor: pointer; transition: color 0.2s ease;" onmouseover="this.style.color=\'#2d9a5a\'" onmouseout="this.style.color=\'#1A733E\'">' + escapeHtml(interactionId) + '</a>';
    } else {
        interactionIdHtml = '<span style="font-size: 0.4852rem; color: #1f2937; font-family: \'Poppins\', sans-serif; font-weight: 600;">N/A</span>';
    }

    // Generate recommendations HTML
    const recommendationsHtml = audit.recommendations 
        ? `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><div style="background: white; padding: 0.5659rem; border-radius: 0.2425rem; border: 0.0304rem solid #e5e7eb; white-space: pre-wrap; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif;">${audit.recommendations}</div></div>`
        : '';

    // Check if current user is the audited employee (for showing acknowledge button)
    const showAcknowledgeButton = isCurrentUserAuditedEmployee();
    
    // Check if edit button should be shown (only for Quality Analysts when reversal is pending)
    const showEditButton = shouldShowEditButton();
    
    // Check if reversal button should be shown (hide after 48 hours from audit submission)
    const auditSubmissionTime = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
    const showReversalButton = checkIfReversalButtonShouldShow(auditSubmissionTime);
    
    // Get reversal and acknowledgement status for footer styling
    // Note: reversal_status column doesn't exist - status is determined by reversal_approved
    const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
    const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
    const reversalApproved = audit.reversal_approved || audit.reversalApproved;
    // Determine status: null/undefined = pending, 'true' = approved, 'false' = rejected
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';

    // Generate action buttons HTML
    // Only show acknowledge/reversal buttons if current user is the audited employee
    let employeeButtonsHtml = '';
    if (showAcknowledgeButton) {
        // Check if reversal is pending (disables acknowledge button and reversal button)
        const isReversalPending = reversalStatus === 'Pending';
        
        // Generate reversal button HTML (always show if within 48 hours, regardless of acknowledgement status)
        // But disable if reversal is already pending
        let reversalButtonHtml = '';
        if (showReversalButton) {
            const reversalDisabled = isReversalPending;
            reversalButtonHtml = `
                <button id="reversalBtn" onclick="toggleReversalForm()" ${reversalDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: ${acknowledgementStatus === 'Acknowledged' ? '0.2425rem' : '0 0.2425rem 0.2425rem 0'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${reversalDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${reversalDisabled ? '0.5' : '1'}; ${acknowledgementStatus !== 'Acknowledged' ? 'border-left: 0.0304rem solid rgba(255,255,255,0.3);' : ''}">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        Submit Reversal
                    </button>
            `;
        }
        
        // If not acknowledged, show acknowledge button + reversal button
        if (acknowledgementStatus !== 'Acknowledged') {
            // Disable acknowledge button if reversal is pending
            const acknowledgeDisabled = isReversalPending;
            employeeButtonsHtml = `
                <!-- Split button for Acknowledge/Reversal -->
                <div style="position: relative; display: inline-flex;">
                    <button id="acknowledgeBtn" onclick="acknowledgeAudit()" ${acknowledgeDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: ${reversalButtonHtml ? '0.2425rem 0 0 0.2425rem' : '0.2425rem'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${acknowledgeDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${acknowledgeDisabled ? '0.5' : '1'};">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Acknowledge
                    </button>
                    ${reversalButtonHtml}
                </div>
            `;
        } else {
            // If acknowledged, only show reversal button (if within 48 hours)
            if (reversalButtonHtml) {
                employeeButtonsHtml = reversalButtonHtml;
            }
        }
    }
    
    // Generate edit button HTML (only if pending reversal and user is Quality Analyst)
    let editButtonHtml = '';
    if (showEditButton) {
        editButtonHtml = `
                <button id="editAuditBtn" onclick="editCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #f59e0b; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Edit Audit
                </button>
        `;
    }
    
    // Determine footer background color based on acknowledgement status
    // Green: Acknowledged | Gray: Default (not acknowledged)
    let footerBackgroundColor = '#f9fafb'; // Default gray
    let footerTextColor = '#6b7280'; // Default gray text
    
    // Normalize acknowledgement status (case-insensitive)
    const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
    
    if (acknowledgementStatusLower === 'acknowledged') {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Generate timer HTML for footer (if reversal button is visible and within 48 hours)
    // Don't show timer if reversal is already pending
    let timerHtml = '';
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        if (timeRemaining && timeRemaining > 0) {
            // Check if time is running low (less than 2 hours remaining)
            const isLowTime = timeRemaining < 7200; // 2 hours in seconds
            // Use white for green footer, default gray text for gray footer
            const acknowledgementStatusLower = (acknowledgementStatus || '').toLowerCase();
            const timerTextColor = acknowledgementStatusLower === 'acknowledged' ? 'white' : footerTextColor;
            timerHtml = `
                <div id="reversalTimer" style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; color: ${timerTextColor}; ${isLowTime ? 'animation: pulse-attention 2s ease-in-out infinite;' : ''}">
                    <svg id="reversalTimerIcon" style="width: 0.75rem; height: 0.75rem; opacity: 0.6; ${isLowTime ? 'animation: spin-slow 2s linear infinite;' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span id="reversalTimerText">Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${isLowTime ? '#ef4444' : timerTextColor}; ${isLowTime ? 'animation: flash-text 1s ease-in-out infinite;' : ''}">${formatTimeRemaining(timeRemaining)}</span></span>
            </div>
            `;
        }
    }
    
    // Generate acknowledgement status HTML for footer (shown in body of footer)
    let acknowledgementStatusHtml = '';
    if (acknowledgementStatus === 'Acknowledged') {
        // Format acknowledgement timestamp
        let timestampText = '';
        const ackTimestamp = audit.acknowledgementStatusUpdatedAt || audit.acknowledgement_status_updated_at;
        if (ackTimestamp) {
            const ackDate = new Date(ackTimestamp);
            const now = new Date();
            const diffMs = now - ackDate;
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffHours < 1) {
                const diffMins = Math.floor(diffMs / (1000 * 60));
                timestampText = diffMins <= 1 ? 'just now' : `${diffMins} minutes ago`;
            } else if (diffHours < 24) {
                timestampText = diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
            } else if (diffDays === 1) {
                timestampText = '1 day ago';
            } else {
                timestampText = formatDate(ackTimestamp, true);
            }
        }
        
        acknowledgementStatusHtml = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background-color: rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                    <svg style="width: 0.875rem; height: 0.875rem;" viewBox="0 0 24 24" fill="white">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                </div>
                <span style="font-size: 0.75rem; font-weight: 600; color: white; font-family: 'Poppins', sans-serif;">Acknowledged</span>
                <span style="font-size: 0.6562rem; color: rgba(255, 255, 255, 0.9); font-family: 'Poppins', sans-serif;">${timestampText}</span>
            </div>
        `;
    }
    
    const actionButtonsHtml = `
        <div id="footerBar" class="no-print" style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid ${acknowledgementStatus === 'Acknowledged' ? 'rgba(255,255,255,0.2)' : '#e5e7eb'}; background-color: ${footerBackgroundColor}; color: ${footerTextColor};">
            <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1;">
                ${acknowledgementStatusHtml}
            </div>
            <div style="display: flex; align-items: center; gap: 0.4852rem; margin-left: auto;">
                ${timerHtml}
                ${employeeButtonsHtml}
                ${editButtonHtml}
            </div>
        </div>
    `;

    // Generate header actions HTML
    const headerActionsHtml = `
        <button onclick="handleCloseButtonClick()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">×</button>
    `;

    // Use shared template to generate HTML
    const html = window.generateAuditFormHTML({
        audit: audit,
        mode: 'view',
        headerTitle: 'Audit Details',
        headerGradient: headerGradient,
        headerActions: headerActionsHtml,
        interactionIdHtml: interactionIdHtml,
        errorDetailsHtml: errorDetailsHtml,
        recommendationsHtml: recommendationsHtml,
        actionButtonsHtml: actionButtonsHtml
    });

    const auditContentDiv = document.getElementById('auditContent');

    // Preserve reversal form container state before re-rendering
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    const wasFormVisible = reversalFormContainer && reversalFormContainer.style.display !== 'none';
    
    // Temporarily remove form container from DOM to preserve it during innerHTML replacement
    let formContainerParent = null;
    let formContainerNextSibling = null;
    if (reversalFormContainer && reversalFormContainer.parentElement) {
        formContainerParent = reversalFormContainer.parentElement;
        formContainerNextSibling = reversalFormContainer.nextSibling;
        reversalFormContainer.remove();
    }
    
    auditContentDiv.innerHTML = html;

    // Re-insert reversal form container after rendering
    if (reversalFormContainer && auditContentDiv) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection && buttonsSection.parentElement) {
            buttonsSection.parentElement.insertBefore(reversalFormContainer, buttonsSection.nextSibling);
        } else {
            auditContentDiv.appendChild(reversalFormContainer);
        }
        
        // Restore visibility state
        if (wasFormVisible) {
            reversalFormContainer.style.display = 'block';
        } else {
            reversalFormContainer.style.display = 'none';
        }
    }

    // Handle reversal status UI updates
    handleReversalStatusUI(audit);
    
    // Display submitted reversal form if reversal is pending
    if (reversalStatus === 'Pending') {
        displaySubmittedReversalForm(audit);
    }
    
    // Start timer countdown if reversal button is visible and reversal is not pending
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        startReversalTimer(auditSubmissionTime);
    }

    // Make splitter draggable
    initializeSplitter();
    
    // Auto-fetch conversation from Intercom if interaction ID exists
    // Chat view is always shown by default (will show loading, then Intercom messages or fallback to text)
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    
    if (transcriptChatView && transcriptTextView) {
        transcriptChatView.style.display = 'flex';
        transcriptTextView.style.display = 'none';
        isChatViewActive = true;
    }
    
    if (audit.interactionId || audit.interaction_id) {
        const interactionId = audit.interactionId || audit.interaction_id;
        // Show loading state immediately
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        if (chatMessagesContainer) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                    <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                </div>
            `;
        }
        // Delay slightly to ensure DOM is ready, then fetch
        setTimeout(() => {
            loadConversationFromIntercom(interactionId);
        }, 100);
    } else {
        // No interaction ID - try to parse database transcript and show in chat view
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - auto-fallback to text view
            if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'none';
            transcriptTextView.style.display = 'flex';
            isChatViewActive = false;
            }
        }
    }
}

// Handle reversal status UI updates
function handleReversalStatusUI(audit) {
    const acknowledgeBtn = document.getElementById('acknowledgeBtn');
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    
    // Check if acknowledge button should be visible (only for audited employee)
    if (acknowledgeBtn && !isCurrentUserAuditedEmployee()) {
        // Hide acknowledge button if user is not the audited employee
        acknowledgeBtn.style.display = 'none';
        // Also hide the reversal button if both buttons are in a split button container
        const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
        if (reversalBtn) {
            reversalBtn.style.display = 'none';
        }
    }
    
    // Get the reversal status from audit data
    // Note: reversal_status column doesn't exist - derive from reversal_approved
    const reversalRequestedAt = currentAudit?.reversal_requested_at || currentAudit?.reversalRequestedAt;
    const reversalRespondedAt = currentAudit?.reversal_responded_at || currentAudit?.reversalRespondedAt;
    const reversalApproved = currentAudit?.reversal_approved || currentAudit?.reversalApproved;
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    // Get the acknowledgement status from audit data
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status;
    
    // Ensure button is enabled by default (will be disabled if needed below)
    if (acknowledgeBtn) {
        acknowledgeBtn.disabled = false;
        acknowledgeBtn.style.opacity = '1';
        acknowledgeBtn.style.cursor = 'pointer';
    }
    
    // If audit is already acknowledged, disable the acknowledge button
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    // If reversal is pending, disable acknowledge button (can't acknowledge while reversal is pending)
    if (reversalStatus === 'Pending' && acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    if (reversalStatus) {
        // Create status banner
        const statusBanner = document.createElement('div');
        statusBanner.style.cssText = `
            padding: 0.5625rem 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.2812rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.6562rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        `;
        
        if (reversalStatus === 'Pending') {
            statusBanner.style.background = '#fef3c7';
            statusBanner.style.color = '#92400e';
            statusBanner.style.border = '0.0352rem solid #fbbf24';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <span>Reversal request is pending review by the quality team. You cannot acknowledge until the reversal is processed.</span>
            `;
            // Disable the reversal button (user can't submit another reversal while one is pending)
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = true;
                reversalBtn.style.opacity = '0.5';
                reversalBtn.style.cursor = 'not-allowed';
            }
        } else if (reversalStatus === 'Approved') {
            statusBanner.style.background = '#d1fae5';
            statusBanner.style.color = '#065f46';
            statusBanner.style.border = '0.0352rem solid #10b981';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <span>✓ Reversal request has been approved. Score updated to ${currentAudit?.score_after_appeal || 'N/A'}%. Please review the updated audit and acknowledge or submit a new reversal if needed.</span>
            `;
            // After reversal is processed, enable both buttons again (new review cycle)
            // Don't hide buttons - allow user to acknowledge or submit new reversal
            if (acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Rejected') {
            statusBanner.style.background = '#fee2e2';
            statusBanner.style.color = '#991b1b';
            statusBanner.style.border = '0.0352rem solid #ef4444';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <span>Reversal request has been rejected. Please review the audit and acknowledge or submit a new reversal if needed.</span>
            `;
            // After reversal is processed, enable both buttons again (new review cycle)
            // Don't hide buttons - allow user to acknowledge or submit new reversal
            if (acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Acknowledged') {
            statusBanner.style.background = '#dbeafe';
            statusBanner.style.color = '#1e40af';
            statusBanner.style.border = '0.0352rem solid #3b82f6';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <span>Audit has been acknowledged by the employee.</span>
            `;
            // Hide the button container (parent div with border-top style)
            const buttonsContainer = acknowledgeBtn?.closest('.no-print[style*="border-top"]');
            if (buttonsContainer) {
                buttonsContainer.style.display = 'none';
            }
        }
        
        // Insert reversal status banner into the DOM
        if (statusBanner) {
        const auditContentDiv = document.getElementById('auditContent');
        if (auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection && buttonsSection.parentElement) {
                buttonsSection.parentElement.insertBefore(statusBanner, buttonsSection);
            } else {
                auditContentDiv.appendChild(statusBanner);
            }
        }
    }
    }
    
    // Handle acknowledgement status separately
    // Note: Acknowledgement status is now shown in the footer, not as a separate banner
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
}

// Display submitted reversal form details (read-only)
function displaySubmittedReversalForm(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) return;
    
    // Get reversal data from audit
    const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
    const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
    const reversalMetrics = audit.reversalMetricsParameters || audit.reversal_metrics_parameters || '';
    const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    
    // Parse reversal justification (may contain reason and justification combined)
    let reversalReason = '';
    let detailedJustification = reversalJustification;
    if (reversalJustification && reversalJustification.includes(':')) {
        const parts = reversalJustification.split(':');
        if (parts.length >= 2) {
            reversalReason = parts[0].trim();
            detailedJustification = parts.slice(1).join(':').trim();
        }
    }
    
    // Format reversal requested date
    let requestedDateText = '';
    if (reversalRequestedAt) {
        const date = new Date(reversalRequestedAt);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) {
            requestedDateText = 'just now';
        } else if (diffMins < 60) {
            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        } else if (diffHours < 24) {
            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        } else if (diffDays === 1) {
            requestedDateText = '1 day ago';
        } else {
            requestedDateText = date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    // Parse metrics parameters
    const selectedParameters = reversalMetrics ? reversalMetrics.split(',').map(p => p.trim()).filter(p => p) : [];
    
    // Create read-only reversal form display
    const submittedFormHtml = `
        <div id="submittedReversalForm" class="no-print" style="background: #fef3c7; border: 0.0703rem solid #fbbf24; border-radius: 0.375rem; padding: 0.75rem; margin: 1.125rem; box-shadow: 0 0.0703rem 0.2812rem rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5625rem;">
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.9375rem; height: 0.9375rem; color: #f59e0b;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    <h3 style="margin: 0; font-size: 0.75rem; font-weight: 700; color: #b45309; font-family: 'Poppins', sans-serif;">Submitted Reversal Request</h3>
                </div>
                <span style="font-size: 0.5625rem; color: #92400e; font-family: 'Poppins', sans-serif;">Submitted ${requestedDateText}</span>
            </div>
            
            <div style="display: grid; gap: 0.5625rem; background: white; border-radius: 0.2812rem; padding: 0.75rem; border: 0.0352rem solid #e5e7eb;">
                <!-- Two-column grid for compact layout -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5625rem;">
                    <!-- Reversal Type -->
                    <div>
                        <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                            Reversal Type
                        </label>
                        <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151;">
                            ${escapeHtml(reversalType)}
                        </div>
                    </div>
                    
                    <!-- Reversal Reason -->
                    ${reversalReason ? `
                        <div>
                            <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                                Reversal Reason
                            </label>
                            <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151;">
                                ${escapeHtml(reversalReason)}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <!-- Affected Error Parameters with Justifications -->
                ${selectedParameters.length > 0 ? `
                    <div>
                        <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                            Parameter Justifications
                        </label>
                        <div style="padding: 0.5625rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151; max-height: 18.75rem; overflow-y: auto;">
                            ${selectedParameters.map(param => {
                                // Try to find matching comment from parameter comments
                                // Use currentAudit which has the latest data, or fall back to audit parameter
                                const auditData = currentAudit || audit;
                                const parameterComments = auditData.parameterComments || auditData.parameter_comments || {};
                                let paramComment = '';
                                
                                // Find the field key that matches this parameter label
                                // currentErrorFields should be available, but if not, try to find from audit data
                                let matchingField = null;
                                if (currentErrorFields && currentErrorFields.length > 0) {
                                    matchingField = currentErrorFields.find(f => f.label === param);
                                }
                                
                                // If found matching field, get comment from parameter_comments using field key
                                if (matchingField) {
                                    const comment = parameterComments[matchingField.key];
                                    if (comment && comment.comment) {
                                        paramComment = comment.comment;
                                    }
                                }
                                
                                // If no comment found from parameter_comments, try to extract from detailedJustification
                                if (!paramComment && detailedJustification) {
                                    const lines = detailedJustification.split('\n\n');
                                    for (const line of lines) {
                                        if (line.trim().startsWith(param + ':')) {
                                            paramComment = line.substring(param.length + 1).trim();
                                            break;
                                        }
                                    }
                                }
                                
                                // If still no comment found, try searching all parameter_comments for any comment that might match
                                if (!paramComment && Object.keys(parameterComments).length > 0) {
                                    // Try to find by matching parameter label with any comment
                                    for (const [key, commentData] of Object.entries(parameterComments)) {
                                        if (commentData && commentData.comment) {
                                            // Check if this field's label matches the param
                                            const field = currentErrorFields?.find(f => f.key === key);
                                            if (field && field.label === param) {
                                                paramComment = commentData.comment;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                return `
                                    <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                                        <div style="font-size: 0.6562rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                                <svg style="width: 0.75rem; height: 0.75rem; color: #10b981; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                                </svg>
                                            ${escapeHtml(param)}
                                        </div>
                                        ${paramComment ? `
                                            <div style="font-size: 0.5625rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; padding-left: 1.125rem;">
                                                ${escapeHtml(paramComment)}
                                            </div>
                                        ` : '<div style="font-size: 0.5625rem; color: #9ca3af; font-family: \'Poppins\', sans-serif; padding-left: 1.125rem; font-style: italic;">No justification provided</div>'}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Within Auditor Scope -->
                <div>
                    <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Within Auditor Scope
                    </label>
                    <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151; display: flex; align-items: center; gap: 0.375rem;">
                        ${withinAuditorScope === 'true' || withinAuditorScope === true ? `
                            <svg style="width: 0.75rem; height: 0.75rem; color: #10b981;" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                            </svg>
                            <span>Yes - I believe this can be resolved by the original auditor</span>
                        ` : `
                            <svg style="width: 0.75rem; height: 0.75rem; color: #6b7280;" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                            <span>No</span>
                        `}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Insert submitted form after the footer bar
    const footerBar = document.getElementById('footerBar');
    if (footerBar && footerBar.parentElement) {
        // Check if already exists, remove it first
        const existingForm = document.getElementById('submittedReversalForm');
        if (existingForm) {
            existingForm.remove();
        }
        
        // Insert after footer bar
        footerBar.parentElement.insertAdjacentHTML('afterend', submittedFormHtml);
    } else {
        // Fallback: append to audit content
        auditContentDiv.insertAdjacentHTML('beforeend', submittedFormHtml);
    }
}

// Start reversal timer countdown
function startReversalTimer(auditSubmissionTime) {
    const timerElement = document.getElementById('reversalTimer');
    const timerTextElement = document.getElementById('reversalTimerText');
    const timerValueElement = document.getElementById('reversalTimerValue');
    const timerIconElement = document.getElementById('reversalTimerIcon');
    
    if (!timerElement || !timerTextElement) {
        return;
    }
    
    // Update timer every second
    const updateTimer = () => {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        
        if (timeRemaining <= 0) {
            // Timer expired - hide reversal button
            timerElement.style.display = 'none';
            const reversalBtn = document.getElementById('reversalBtn');
            if (reversalBtn) {
                reversalBtn.style.display = 'none';
                // Adjust acknowledge button border radius if reversal button is hidden
                const acknowledgeBtn = document.getElementById('acknowledgeBtn');
                if (acknowledgeBtn) {
                    acknowledgeBtn.style.borderRadius = '0.2425rem';
                }
            }
            return;
        }
        
        // Check if time is running low (less than 2 hours)
        const isLowTime = timeRemaining < 7200; // 2 hours in seconds
        const isVeryLowTime = timeRemaining < 3600; // 1 hour in seconds
        const isCriticalTime = timeRemaining < 600; // 10 minutes in seconds
        
        // Determine color and animation based on time remaining
        let timerColor = '#374151';
        let timerAnimation = 'none';
        let elementAnimation = 'none';
        let elementColor = '#6b7280';
        let elementFontWeight = '500';
        let iconColor = '';
        let iconAnimation = 'none';
        let iconOpacity = '0.6';
        
        if (isCriticalTime) {
            // Critical: Red color, flash animation, shake effect
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 0.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1s ease-in-out infinite, shake 0.5s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '700';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isVeryLowTime) {
            // Very low: Orange color, pulse animation
            timerColor = '#f59e0b';
            timerAnimation = 'flash-text 1s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1.5s ease-in-out infinite';
            elementColor = '#f59e0b';
            elementFontWeight = '600';
            iconColor = '#f59e0b';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isLowTime) {
            // Low: Red color, subtle pulse
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 1.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 2s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '600';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        }
        
        // Get current footer to determine text color
        const footerBar = document.getElementById('footerBar');
        let defaultTimerColor = '#374151';
        let defaultTextColor = '#6b7280';
        
        if (footerBar) {
            const bgColor = footerBar.style.backgroundColor || window.getComputedStyle(footerBar).backgroundColor;
            const isFooterGreen = bgColor.includes('rgb(6, 95, 70)') || bgColor.includes('#065f46');
            
            if (isFooterGreen) {
                defaultTimerColor = 'white';
                defaultTextColor = 'white';
            }
        }
        
        // For critical time, use red; otherwise use the footer-appropriate color (white for green, gray for default)
        const finalTimerColor = isCriticalTime ? '#ef4444' : defaultTimerColor;
        
        timerTextElement.innerHTML = `Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${finalTimerColor}; animation: ${timerAnimation};">${formatTimeRemaining(timeRemaining)}</span>`;
        
        // Apply styles to timer element
        timerElement.style.animation = elementAnimation;
        timerElement.style.color = defaultTextColor;
        timerElement.style.fontWeight = elementFontWeight;
        
        // Update icon animation
        const currentIconElement = document.getElementById('reversalTimerIcon');
        if (currentIconElement) {
            currentIconElement.style.color = iconColor;
            currentIconElement.style.animation = iconAnimation;
            currentIconElement.style.opacity = iconOpacity;
        }
        
        // Continue updating
        setTimeout(updateTimer, 1000);
    };
    
    // Start the timer
    updateTimer();
}

// Toggle function removed - chat view is always shown, with auto-fallback to text view only on failure

// Intercom API Integration
let currentConversationData = null;
let isChatViewActive = false;

// Get Intercom and Supabase config (use existing globals from config files if available)
const INTERCOM_CONFIG = window.intercomConfig || {
    baseUrl: 'https://app.intercom.com',
    appId: ''
};

// Get Supabase config from window.SupabaseConfig (set by supabase-config.js)
// Use local variables with different names to avoid conflicts
const supabaseUrl = window.SupabaseConfig?.url || '';
const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';

// Fetch conversation from Intercom API
async function loadConversationFromIntercom(conversationId) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    
    if (!chatMessagesContainer || !transcriptChatView) return;
    
    // Show loading state
    chatMessagesContainer.innerHTML = `
        <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
            <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
        </div>
    `;

    try {
        // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}`;
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const conversation = await response.json();
        currentConversationData = conversation;

        // Parse and display conversation messages
        displayConversationMessages(conversation);

        // Extract and display all conversation attributes
        displayConversationAttributes(conversation);

        // Ensure chat view is active (it should already be)
        if (!isChatViewActive) {
            isChatViewActive = true;
            transcriptChatView.style.display = 'flex';
            if (transcriptTextView) transcriptTextView.style.display = 'none';
        }

    } catch (error) {
        console.error('Error loading conversation from Intercom:', error);
        
        // Try to parse database transcript as fallback
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - auto-fallback to text view
            const transcriptChatView = document.getElementById('transcriptChatView');
            const transcriptTextView = document.getElementById('transcriptTextView');
            
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'none';
                transcriptTextView.style.display = 'flex';
                isChatViewActive = false;
            }
            
            // Show error message in chat container (for debugging, but user will see text view)
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                    <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                    <p style="font-size: 0.4852rem; color: #6b7280;">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: #9ca3af; margin-top: 0.3234rem;">No database transcript available.</p>
                </div>
            `;
        }
    }
}

// Display conversation messages in chat interface
function displayConversationMessages(conversation) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    if (!chatMessagesContainer) return;
    
    const parts = conversation.conversation_parts?.conversation_parts || [];
    
    if (parts.length === 0) {
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af;">
                <p>No messages found in this conversation.</p>
            </div>
        `;
        return;
    }

    // Sort parts by created_at timestamp
    const sortedParts = [...parts].sort((a, b) => {
        const timeA = typeof a.created_at === 'number' ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at) : new Date(a.created_at).getTime();
        const timeB = typeof b.created_at === 'number' ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at) : new Date(b.created_at).getTime();
        return timeA - timeB;
    });

    chatMessagesContainer.innerHTML = '';

    sortedParts.forEach(part => {
        const message = part.body || '';
        const author = part.author || {};
        const authorName = author.name || author.email || 'Unknown';
        const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
        const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
        
        // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
        let timestamp;
        if (typeof part.created_at === 'number') {
            // Unix timestamp in seconds - convert to milliseconds
            timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
        } else {
            timestamp = new Date(part.created_at);
        }
        const isUser = authorType === 'user' || authorType === 'contact';
        
        // Format the message body to check if it has content
        const formattedMessage = formatMessageBody(message);
        
        // Skip empty messages or non-comment parts (like assignments, system messages, etc.)
        // Only show parts that have actual text content
        if (!formattedMessage || formattedMessage.trim() === '' || formattedMessage.trim() === '{}') {
            return; // Skip this part
        }
        
        // Also skip if part type is not a comment (assignment, system messages, etc.)
        if (partType !== 'comment' && partType !== 'note') {
            return; // Skip non-comment parts
        }
        
        // Format timestamp
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });

        // Create message bubble
        // User messages on LEFT (white), Agent messages on RIGHT (green)
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-bottom: 0.3234rem;
            align-items: ${isUser ? 'flex-start' : 'flex-end'};
        `;

        // Switched colors: Agent = flat green, User = white
        const bubbleStyle = isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 75%;
                margin-right: auto;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 75%;
                margin-left: auto;
            `;

        // Compact layout: timestamp next to sender name for both user and agent messages
        messageDiv.innerHTML = `
            <div style="${bubbleStyle} padding: 0.3234rem 0.4852rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08);">
                ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">User</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                <div style="font-size: 0.5257rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word;">${formattedMessage}</div>
            </div>
        `;

        chatMessagesContainer.appendChild(messageDiv);
    });

    // Scroll to bottom
    const transcriptChatView = document.getElementById('transcriptChatView');
    if (transcriptChatView) {
        transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
    }
}

// Format message body (handle HTML/plain text)
function formatMessageBody(body) {
    if (!body) return '';
    
    // If body is an object, extract text
    if (typeof body === 'object') {
        // Handle empty objects
        if (Object.keys(body).length === 0) return '';
        
        // Check for text content in various possible fields
        if (body.plaintext) {
            const text = String(body.plaintext).trim();
            return text ? escapeHtml(text) : '';
        }
        if (body.text) {
            const text = String(body.text).trim();
            return text ? escapeHtml(text) : '';
        }
        if (body.body) {
            const text = String(body.body).trim();
            return text ? escapeHtml(text) : '';
        }
        
        // Check for HTML content
        if (body.html) {
            const text = String(body.html).replace(/<[^>]*>/g, '').trim();
            return text ? escapeHtml(text) : '';
        }
        
        // If object has no text content, return empty
        // Don't stringify as that would just show "{}"
        return '';
    }
    
    // Handle string body
    const text = String(body).replace(/<[^>]*>/g, '').trim();
    
    // Return empty if text is empty or just whitespace/JSON-like structures
    if (!text || text === '{}' || text === '[]' || text === 'null' || text === 'undefined') {
        return '';
    }
    
    return escapeHtml(text);
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Toggle conversation attributes panel (via details button)
// Function removed - attributes are now always shown by default

// Display all conversation attributes in UI-friendly format
function displayConversationAttributes(conversation) {
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const chatGrid = document.getElementById('conversationAttributesGrid');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    const textGrid = document.getElementById('conversationAttributesGridTextView');
    
    if (!chatGrid || !textGrid) return;
    
    // Clear existing content
    chatGrid.innerHTML = '';
    textGrid.innerHTML = '';
    
    let attributeCount = 0;
    const attributes = extractConversationAttributes(conversation);
    
    // Helper function to format value
    const formatValue = (key, value) => {
        if (value === null || value === undefined) return '<span style="color: #9ca3af; font-style: italic;">Not set</span>';
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        
        // Handle URLs (for Web Link)
        if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
            const url = String(value);
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom →</a>`;
            }
        }
        
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (value.length === 0) return '<span style="color: #9ca3af; font-style: italic;">None</span>';
                return value.map(item => {
                    if (typeof item === 'object') {
                        return Object.values(item).filter(v => v).join(' - ');
                    }
                    return String(item);
                }).join(', ');
            }
            return JSON.stringify(value, null, 2);
        }
        return escapeHtml(String(value));
    };
    
    // Create attribute cards for both views
    const createAttributeCard = (key, value) => {
        const card = document.createElement('div');
        card.style.cssText = `
            background: #f9fafb;
            border: 0.0304rem solid #e5e7eb;
            border-radius: 0.1617rem;
            padding: 0.2425rem 0.3234rem;
            transition: all 0.2s ease;
        `;
        
        card.onmouseenter = () => {
            card.style.borderColor = '#1A733E';
            card.style.boxShadow = '0 0.0606rem 0.1213rem rgba(26, 115, 62, 0.1)';
            card.style.backgroundColor = '#ffffff';
        };
        
        card.onmouseleave = () => {
            card.style.borderColor = '#e5e7eb';
            card.style.boxShadow = 'none';
            card.style.backgroundColor = '#f9fafb';
        };
        
        const label = formatLabelForAttribute(key);
        const formattedValue = formatValue(key, value);
        
        card.innerHTML = `
            <div style="font-size: 0.3639rem; color: #6b7280; font-weight: 600; text-transform: uppercase; letter-spacing: 0.0122rem; margin-bottom: 0.0808rem; font-family: 'Poppins', sans-serif; line-height: 1.2;">${escapeHtml(label)}</div>
            <div style="font-size: 0.4852rem; color: #1f2937; font-weight: 500; word-wrap: break-word; line-height: 1.3; font-family: 'Poppins', sans-serif;">${formattedValue}</div>
        `;
        
        return card;
    };
    
    Object.entries(attributes).forEach(([key, value]) => {
        if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
            return; // Skip empty values
        }
        
        attributeCount++;
        
        // Create cards for both views
        const chatCard = createAttributeCard(key, value);
        const textCard = createAttributeCard(key, value);
        
        chatGrid.appendChild(chatCard);
        textGrid.appendChild(textCard);
    });
    
    // Show panels by default if attributes found
    if (attributeCount > 0) {
        console.log('Attributes loaded:', attributeCount, 'items');
        
        // Check which view is currently active and show appropriate panel
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        const chatViewStyle = transcriptChatView ? window.getComputedStyle(transcriptChatView).display : 'none';
        const isChatView = chatViewStyle !== 'none' && chatViewStyle !== '';
        
            // Get the transcript container to match its height (left column details section)
            const transcriptContainer = transcriptChatView?.parentElement || transcriptTextView?.parentElement;
        
            if (isChatView && chatPanel && transcriptContainer) {
            chatPanel.style.display = 'block';
                // Match height to transcript container (left column details)
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        chatPanel.style.maxHeight = transcriptHeight + 'px';
                        chatPanel.style.height = 'auto';
                    }
                }, 100);
            } else if (!isChatView && textPanel && transcriptContainer) {
            textPanel.style.display = 'block';
                // Match height to transcript container (left column details)
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        textPanel.style.maxHeight = transcriptHeight + 'px';
                        textPanel.style.height = 'auto';
                    }
                }, 100);
        }
    } else {
        // Hide panels if no attributes
        if (chatPanel) {
            chatPanel.style.display = 'none';
        }
        if (textPanel) {
            textPanel.style.display = 'none';
        }
    }
}

// Helper function to format label (used in both functions)
function formatLabelForAttribute(label) {
    return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Extract all relevant conversation attributes from Intercom API response
function extractConversationAttributes(conversation) {
    const attributes = {};
    
    // Helper function to convert Unix timestamp to readable date
    const formatTimestamp = (timestamp) => {
        if (!timestamp) return null;
        const date = typeof timestamp === 'number' 
            ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
            : new Date(timestamp);
        if (isNaN(date.getTime())) return null;
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    };
    
    // Basic Information
    if (conversation.id) attributes['Conversation ID'] = conversation.id;
    if (conversation.type) attributes['Type'] = conversation.type;
    if (conversation.state) attributes['State'] = conversation.state;
    if (conversation.read !== undefined) attributes['Read'] = conversation.read;
    if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
    if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
    if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
    
    // Source Information
    if (conversation.source) {
        if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
        if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
        if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
        if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
        
        // Author (who initiated)
        if (conversation.source.author) {
            const author = conversation.source.author;
            if (author.type) attributes['Author Type'] = author.type;
            if (author.id) attributes['Author ID'] = author.id;
            if (author.name) attributes['Author Name'] = author.name;
            if (author.email) attributes['Author Email'] = author.email;
        }
        
        // Owner (assigned to)
        if (conversation.source.owner) {
            const owner = conversation.source.owner;
            if (owner.type) attributes['Owner Type'] = owner.type;
            if (owner.id) attributes['Owner ID'] = owner.id;
            if (owner.name) attributes['Assigned To'] = owner.name;
            if (owner.email) attributes['Owner Email'] = owner.email;
        }
    }
    
    // Statistics
    if (conversation.statistics) {
        const stats = conversation.statistics;
        if (stats.time_to_assignment) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
        if (stats.time_to_admin_reply) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
        if (stats.time_to_first_close) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
        if (stats.time_to_last_close) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
        if (stats.median_time_to_reply) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
        if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
        if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
        if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
        if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
        if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
        if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
    }
    
    // Tags
    if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
        attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
    }
    
    // Teammates (participating admins)
    if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
        attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
            teammate.name || teammate.email || teammate.id
        ).join(', ');
    }
    
    // Contacts (users involved)
    if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
        const contacts = conversation.contacts.contacts.map(contact => {
            const parts = [];
            if (contact.name) parts.push(contact.name);
            if (contact.email) parts.push(contact.email);
            return parts.length > 0 ? parts.join(' - ') : contact.id;
        });
        attributes['Contacts'] = contacts.join(', ');
    }
    
    // Conversation Parts Summary
    if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
        const parts = conversation.conversation_parts.conversation_parts;
        attributes['Total Messages'] = parts.length;
    }
    
    // Custom Attributes (if present)
    if (conversation.source && conversation.source.custom && conversation.source.custom.length > 0) {
        conversation.source.custom.forEach(attr => {
            if (attr.value !== null && attr.value !== undefined && attr.value !== '') {
                attributes[attr.name || 'Custom Attribute'] = attr.value;
            }
        });
    }
    
    return attributes;
}

// Parse plain text transcript and render as chat bubbles (fallback if Intercom fetch fails)
function parseTranscriptToChat(transcriptText, interactionDate) {
    const chatContainer = document.getElementById('chatMessagesContainer');
    if (!chatContainer) return;
    
    if (!transcriptText || !transcriptText.trim()) {
        chatContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af; font-size: 0.5659rem;">
                <p>No transcript available</p>
            </div>
        `;
        return;
    }
    
    // Clear container
    chatContainer.innerHTML = '';
    
    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Parse transcript - try to detect user/agent messages
    // Common patterns:
    // - "User:" or "Customer:" at start of line
    // - "Agent:" or employee name at start of line
    // - Lines with timestamps
    // - Blank lines as separators
    
    const lines = transcriptText.split('\n').filter(line => line.trim());
    const messages = [];
    let currentMessage = null;
    
    // Use interaction date as base for timestamps
    const baseDate = interactionDate ? new Date(interactionDate) : new Date();
    
    // Build agent pattern with employee name if available
    const employeeName = currentAudit?.employeeName || '';
    const agentPatternStr = employeeName 
        ? `^(?:Agent|Support|Representative|${employeeName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}):\\s*(.*)`
        : '^(?:Agent|Support|Representative):\\s*(.*)';
    const agentPattern = new RegExp(agentPatternStr, 'i');
    
    lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
            // Empty line - end current message if exists
            if (currentMessage) {
                messages.push(currentMessage);
                currentMessage = null;
            }
            return;
        }
        
        // Try to detect message patterns
        const userPattern = /^(?:User|Customer|Client):\s*(.*)/i;
        const timestampPattern = /^(\d{1,2}[:\.]\d{2}(?:\s*[AP]M)?|\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/i;
        
        const userMatch = trimmedLine.match(userPattern);
        const agentMatch = trimmedLine.match(agentPattern);
        const timestampMatch = trimmedLine.match(timestampPattern);
        
        if (userMatch) {
            // Start new user message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: userMatch[1].trim(),
                isUser: true,
                author: 'User',
                timestamp: baseDate
            };
        } else if (agentMatch) {
            // Start new agent message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: agentMatch[1].trim(),
                isUser: false,
                author: currentAudit?.employeeName || 'Agent',
                timestamp: baseDate
            };
        } else if (timestampMatch && currentMessage) {
            // Timestamp found at start of line - could be new message or continuation
            // If timestamp is followed by text, it might be a new message
            const afterTimestamp = trimmedLine.substring(timestampMatch[0].length).trim();
            if (afterTimestamp && afterTimestamp.length > 5) {
                // Has substantial content after timestamp - likely new message
                if (currentMessage) messages.push(currentMessage);
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: afterTimestamp,
                    isUser: lastMessage ? !lastMessage.isUser : true,
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            } else {
                // Just timestamp, continue current message
                currentMessage.text += ' ' + trimmedLine;
            }
        } else {
            // Continue current message or start new one if none exists
            if (currentMessage) {
                // Check if line looks like a new speaker (common patterns)
                const looksLikeNewSpeaker = /^[-–—]\s/.test(trimmedLine) || 
                                           /^\[/.test(trimmedLine) ||
                                           trimmedLine.length < 20 && /^[A-Z][a-z]+:/.test(trimmedLine);
                
                if (looksLikeNewSpeaker && currentMessage.text.length > 50) {
                    // End current message and start new one
                    messages.push(currentMessage);
                    const lastMessage = messages[messages.length - 1];
                    currentMessage = {
                        text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                        isUser: lastMessage ? !lastMessage.isUser : true,
                        author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                        timestamp: baseDate
                    };
                } else {
                    currentMessage.text += (currentMessage.text ? '\n' : '') + trimmedLine;
                }
            } else {
                // Try to guess based on context - if previous message was user, this might be agent
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                    isUser: lastMessage ? !lastMessage.isUser : true, // Alternate or default to user
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            }
        }
        
        // Set timestamp for new messages
        if (currentMessage && (!currentMessage.timestamp || currentMessage.timestamp.getTime() === baseDate.getTime())) {
            currentMessage.timestamp = new Date(baseDate.getTime() + messages.length * 60000);
        }
    });
    
    // Add last message
    if (currentMessage) {
        messages.push(currentMessage);
    }
    
    // If no structured messages found, treat entire transcript as single message
    if (messages.length === 0) {
        messages.push({
            text: transcriptText,
            isUser: true,
            author: 'User',
            timestamp: baseDate
        });
    }
    
    // Render messages as chat bubbles
    messages.forEach((msg, index) => {
        const timeStr = msg.timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = msg.timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-bottom: 0.3234rem;
            align-items: ${msg.isUser ? 'flex-start' : 'flex-end'};
        `;
        
        const bubbleStyle = msg.isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 75%;
                margin-right: auto;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 75%;
                margin-left: auto;
            `;
        
        messageDiv.innerHTML = `
            <div style="${bubbleStyle} padding: 0.3234rem 0.4852rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08);">
                ${msg.isUser 
                    ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">User</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` 
                    : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(msg.author)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                <div style="font-size: 0.5257rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(msg.text)}</div>
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
    });
    
    // Scroll to bottom
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Initialize resizable splitter
function initializeSplitter() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditMainContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        let startX = 0;
        let startLeftWidth = 0;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startLeftWidth = leftColumn.offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const containerWidth = containerRect.width;
            
            // Calculate new width based on delta
            let newLeftWidth = startLeftWidth + deltaX;
            
            // Convert to percentage with constraints
            let leftPercentage = (newLeftWidth / containerWidth) * 100;
            leftPercentage = Math.max(25, Math.min(75, leftPercentage));
            
            // Apply width and update right column
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('auditViewSplitterPosition', leftPercentage.toString());
            } catch (err) {
                // Ignore localStorage errors
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Restore saved position from localStorage
        try {
            const savedPosition = localStorage.getItem('auditViewSplitterPosition');
            if (savedPosition) {
                const percentage = parseFloat(savedPosition);
                if (!isNaN(percentage) && percentage >= 25 && percentage <= 75) {
                    leftColumn.style.width = percentage + '%';
                    leftColumn.style.flex = '0 0 ' + percentage + '%';
                }
            }
        } catch (err) {
            // Ignore localStorage errors
        }
    }
}

// Toggle reversal form visibility
function toggleReversalForm() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only submit reversal requests for audits assigned to you.');
        return;
    }
    
    const formContainer = document.getElementById('reversalFormContainer');
    const auditContentDiv = document.getElementById('auditContent');
    
    if (!formContainer) {
        console.error('Reversal form container not found');
        return;
    }
    
    if (!auditContentDiv) {
        console.error('Audit content div not found');
        return;
    }
    
    // Ensure form container is in the DOM (might have been removed during re-render)
    if (!formContainer.parentElement) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection) {
            buttonsSection.parentElement.insertBefore(formContainer, buttonsSection.nextSibling);
        } else {
            auditContentDiv.appendChild(formContainer);
        }
    }
    
    if (formContainer.style.display === 'none' || !formContainer.style.display) {
        formContainer.style.display = 'block';
        
        // Move form container to be after the action buttons if not already in auditContent
        if (auditContentDiv && formContainer.parentElement !== auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection) {
                buttonsSection.parentElement.insertBefore(formContainer, buttonsSection.nextSibling);
            } else {
                auditContentDiv.appendChild(formContainer);
            }
        }
        
        // Comments are automatically collected during form submission
        
        formContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } else {
        formContainer.style.display = 'none';
    }
}

// Make toggleReversalForm globally accessible
window.toggleReversalForm = toggleReversalForm;

// Refresh audit data from database to get latest comments
async function refreshAuditData() {
    if (!currentAudit || !currentTableName) {
        return;
    }
    
    try {
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .select('parameter_comments')
            .eq('id', currentAudit.id)
            .single();
        
        if (error) throw error;
        
        if (data && data.parameter_comments) {
            // Update parameter comments in currentAudit
            currentAudit.parameterComments = data.parameter_comments;
            currentAudit.parameter_comments = data.parameter_comments;
            console.log('Refreshed parameter comments from database:', data.parameter_comments);
        }
    } catch (error) {
        console.error('Error refreshing audit data:', error);
        // Don't throw - just log the error
    }
}

// Populate parameters with comments (compact display)
function populateParametersWithComments() {
    const container = document.getElementById('parametersWithCommentsContainer');
    const noCommentsMsg = document.getElementById('noCommentsMessage');
    
    if (!container) return;
    
    if (currentErrorFields.length === 0) {
        container.innerHTML = '<p style="margin: 0; font-size: 0.5625rem; color: #6b7280; font-family: \'Poppins\', sans-serif;">No parameters available</p>';
        return;
    }
    
    // Get parameter comments from database
    let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    
    // Also check inline comment inputs in the DOM (real-time fallback)
    const inlineComments = {};
    currentErrorFields.forEach(field => {
        const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
        const comments = [];
        commentInputs.forEach(input => {
            if (input.value && input.value.trim()) {
                comments.push(input.value.trim());
            }
        });
        if (comments.length > 0) {
            inlineComments[field.key] = { comments: comments };
        }
    });
    
    // Merge inline comments (takes precedence)
    parameterComments = { ...parameterComments, ...inlineComments };
    
    // Filter only parameters that have comments (check both formats)
    const parametersWithComments = currentErrorFields.filter(field => {
        const fieldComment = parameterComments[field.key];
        if (!fieldComment) return false;
        
        // Check for single comment format: {comment: "text"}
        if (fieldComment.comment && fieldComment.comment.trim()) {
            return true;
        }
        
        // Check for array format: {comments: ["text1", "text2"]}
        if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            return fieldComment.comments.some(c => c && c.trim());
        }
        
        return false;
    });
    
    if (parametersWithComments.length === 0) {
        container.style.display = 'none';
        if (noCommentsMsg) {
            noCommentsMsg.style.display = 'block';
        }
        return;
    }
    
    if (noCommentsMsg) {
        noCommentsMsg.style.display = 'none';
    }
    container.style.display = 'block';
    
    // Create compact list of parameters with comments
    const commentsHtml = parametersWithComments.map(field => {
        const fieldComment = parameterComments[field.key];
        let commentText = '';
        
        // Get comment text (handle both formats)
        if (fieldComment.comment && fieldComment.comment.trim()) {
            commentText = fieldComment.comment.trim();
        } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            // Join all comments with newlines, filter out empty ones, trim each comment, then trim the result
            commentText = fieldComment.comments
                .filter(c => c && c.trim())
                .map(c => c.trim())
                .join('\n')
                .trim();
        }
        
        // Ensure commentText is trimmed to remove leading/trailing whitespace
        commentText = commentText ? commentText.trim() : '';
        
        return `
                <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                    <div style="font-size: 0.6094rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(field.label)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(commentText)}
                    </div>
                </div>
            `;
    }).join('');
    
    container.innerHTML = commentsHtml;
}

// Select all parameters (kept for backward compatibility, but not used)
function selectAllParameters() {
    // Not used anymore - parameters are auto-selected based on comments
}

// Clear all parameters (kept for backward compatibility, but not used)
function clearAllParameters() {
    // Not used anymore - parameters are auto-selected based on comments
}

// Handle close button click - check acknowledgement before closing
async function handleCloseButtonClick() {
    const canNavigate = await handleCloseAuditView();
    if (canNavigate) {
        window.location.href = 'expert-audits.html';
    }
}

// Make handleCloseButtonClick globally accessible
window.handleCloseButtonClick = handleCloseButtonClick;

// Show parameter comment modal
function showParameterCommentModal(fieldId, fieldLabel, auditorFeedback) {
    if (!isCurrentUserAuditedEmployee()) {
        alert('Only the audited employee can add comments.');
        return;
    }
    
    // Get existing comment for this parameter
    const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    const existingComment = parameterComments[fieldId] || null;
    const hasComment = existingComment && existingComment.comment && existingComment.comment.trim();
    
    // Create modal overlay
    const modal = document.createElement('div');
    modal.id = 'parameterCommentModal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 1.125rem;';
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 0.375rem; padding: 1.125rem; max-width: 37.5rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.25rem 0.375rem rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <h3 style="font-size: 0.8438rem; font-weight: 700; color: #1f2937; margin: 0; font-family: 'Poppins', sans-serif;">
                    Add Your Comment - ${escapeHtml(fieldLabel)}
                </h3>
                <button onclick="closeParameterCommentModal()" style="background: none; border: none; font-size: 1.5rem; color: #6b7280; cursor: pointer; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
            </div>
            
            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9fafb; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                    Auditor Feedback
                </div>
                <div style="font-size: 0.6562rem; color: #374151; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(auditorFeedback)}
                </div>
            </div>
            
            ${hasComment ? `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 0.2812rem; border: 0.0352rem solid #bae6fd;">
                    <div style="font-size: 0.5625rem; font-weight: 600; color: #0369a1; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Your Previous Comment
                    </div>
                    <div style="font-size: 0.6562rem; color: #075985; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: 0.375rem;">
                        ${escapeHtml(existingComment.comment)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #0284c7; font-family: 'Poppins', sans-serif;">
                        ${existingComment.commented_at ? new Date(existingComment.commented_at).toLocaleString() : ''}
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 0.75rem;">
                <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    Your Comment / Justification
                </label>
                <textarea 
                    id="modalCommentInput_${fieldId}" 
                    placeholder="Provide your justification or response to the auditor's feedback..." 
                    rows="6"
                    style="width: 100%; padding: 0.75rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; background: white; box-sizing: border-box;"
                >${hasComment ? escapeHtml(existingComment.comment) : ''}</textarea>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem;">
                <button 
                    onclick="closeParameterCommentModal()" 
                    style="padding: 0.5625rem 1.125rem; background: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    Cancel
                </button>
                <button 
                    onclick="saveParameterCommentFromModal('${fieldId}')" 
                    style="padding: 0.5625rem 1.125rem; background: #1A733E; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    ${hasComment ? 'Update' : 'Save'} Comment
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus the textarea
    setTimeout(() => {
        const textarea = document.getElementById(`modalCommentInput_${fieldId}`);
        if (textarea) {
            textarea.focus();
        }
    }, 100);
    
    // Close on overlay click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeParameterCommentModal();
        }
    });
}

// Close parameter comment modal
function closeParameterCommentModal() {
    const modal = document.getElementById('parameterCommentModal');
    if (modal) {
        modal.remove();
    }
}

// Save parameter comment from modal (local only, not to database)
function saveParameterCommentFromModal(fieldId) {
    try {
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        const commentInput = document.getElementById(`modalCommentInput_${fieldId}`);
        if (!commentInput) {
            alert('Error: Comment input not found');
            return;
        }
        
        const commentText = commentInput.value.trim();
        if (!commentText) {
            alert('Please enter a comment before saving.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Update comment for this parameter (local only, not saved to database yet)
        const updatedComments = {
            ...currentComments,
            [fieldId]: {
                comment: commentText,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Update local audit object only (will be saved to database when reversal is submitted)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Close modal
        closeParameterCommentModal();
        
        // Update the inline comment input if it exists (to reflect the change in the table)
        const commentInputs = document.querySelectorAll(`input[data-param-key="${fieldId}"]`);
        if (commentInputs.length > 0) {
            commentInputs[0].value = commentText;
        }
        
        console.log('Comment stored locally (will be saved on reversal submission)');
        
    } catch (error) {
        console.error('Error storing parameter comment locally:', error);
        alert('Failed to store comment locally. Please try again.');
    }
}

// Toggle comments column visibility
function toggleCommentsColumn() {
    if (typeof window.showCommentsColumn === 'undefined') {
        window.showCommentsColumn = false;
    }
    window.showCommentsColumn = !window.showCommentsColumn;
    
    // Update the existing table header and rows without recreating the container
    if (currentAudit && currentErrorFields) {
        // Find the table header row within the Error Details section
        const errorDetailsSection = Array.from(document.querySelectorAll('div')).find(div => {
            const h3 = div.querySelector('h3');
            return h3 && h3.textContent && h3.textContent.includes('Error Details');
        });
        
        if (!errorDetailsSection) return;
        
        // Find header row within the error details section
        const headerRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            const text = div.textContent || '';
            return text.includes('Error Type') && text.includes('Points') && text.includes('Severity');
        });
        
        if (headerRows.length === 0) return;
        
        const header = headerRows[0];
        const showComments = window.showCommentsColumn;
        
        // Get employee first name for column header
        const employeeName = currentAudit.employeeName || currentAudit.employee_name || 'Employee';
        const firstName = employeeName.split(' ')[0] || employeeName;
        const commentColumnHeader = `${firstName}'s Comment`;
        
        // Check if user is audited employee
        const isAuditedEmployee = isCurrentUserAuditedEmployee();
        
        // Update grid columns
        if (showComments) {
            header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
            // Find the "+ Comment" header cell (last child) and replace with actual column header
            const lastHeader = header.lastElementChild;
            if (lastHeader) {
                lastHeader.innerHTML = escapeHtml(commentColumnHeader);
                lastHeader.style.cursor = 'default';
                lastHeader.style.color = '#1f2937';
                lastHeader.style.textDecoration = 'none';
                lastHeader.removeAttribute('onclick');
            } else if (header.children.length === 5) {
                // Add new header cell if it doesn't exist
                const commentHeaderCell = document.createElement('div');
                commentHeaderCell.textContent = commentColumnHeader;
                commentHeaderCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;';
                header.appendChild(commentHeaderCell);
            }
        } else {
            // When hiding comments, keep 6 columns if audited employee (to show + Comment button)
            if (isAuditedEmployee) {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                // Find the comment column header and replace with "+ Comment" button
                const lastHeader = header.lastElementChild;
                if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment"))) {
                    lastHeader.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    lastHeader.style.cursor = 'pointer';
                } else if (header.children.length === 5) {
                    // Add "+ Comment" button if it doesn't exist
                    const commentButtonCell = document.createElement('div');
                    commentButtonCell.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    commentButtonCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1A733E; text-transform: uppercase; letter-spacing: 0.05em;';
                    header.appendChild(commentButtonCell);
                }
            } else {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                // Remove comment column if not audited employee
                if (header.children.length === 6) {
                    const lastHeader = header.lastElementChild;
                    if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment") || lastHeader.textContent.includes("+ Comment"))) {
                        lastHeader.remove();
                    }
                }
            }
        }
        
        // Update all data rows within the error details section
        const dataRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            return div !== header && div.style.display === 'grid' && !div.textContent.includes('Error Type');
        });
        
        dataRows.forEach(row => {
            if (showComments) {
                // Add comment column if not present
                if (row.children.length === 5 || row.children.length === 6) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
                    // Remove existing comment column if present (to refresh it)
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.remove();
                        }
                    }
                    
                    // Get the field key from the row (first child text)
                    const firstCell = row.children[0];
                    const fieldLabel = firstCell.textContent.trim();
                    
                    // Find matching field
                    const field = currentErrorFields.find(f => f.label === fieldLabel);
                    if (field) {
                        // Get feedback data
                        const feedbackData = currentAudit[field.feedback];
                        let feedbackArray = [];
                        
                        if (feedbackData) {
                            if (typeof feedbackData === 'string') {
                                try {
                                    const parsed = JSON.parse(feedbackData);
                                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                } catch (e) {
                                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                }
                            } else if (Array.isArray(feedbackData)) {
                                feedbackArray = feedbackData;
                            }
                        }
                        feedbackArray = feedbackArray.filter(f => f && f.trim());
                        
                        // Get existing comments
                        const parameterComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
                        const existingComments = parameterComments[field.key] || {};
                        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
                        const isAuditedEmployee = isCurrentUserAuditedEmployee();
                        
                        // Check if reversal has been submitted (disable inputs if so)
                        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                        const hasReversalSubmitted = !!reversalRequestedAt;
                        
                        // Create comment column
                        const commentCell = document.createElement('div');
                        commentCell.style.cssText = 'font-size: 0.5659rem; color: #4b5563; font-family: Poppins, sans-serif; min-width: 0; overflow: hidden;';
                        
                        if (feedbackArray.length > 0) {
                            feedbackArray.forEach((feedbackText, index) => {
                                const existingComment = commentsArray[index] || '';
                                const commentInputId = `comment_${field.key}_${index}`;
                                const commentDiv = document.createElement('div');
                                commentDiv.style.marginBottom = index < feedbackArray.length - 1 ? '0.6469rem' : '0';
                                
                                if (feedbackArray.length > 1) {
                                    const label = document.createElement('div');
                                    label.textContent = `Comment ${index + 1}:`;
                                    label.style.cssText = 'font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: Poppins, sans-serif;';
                                    commentDiv.appendChild(label);
                                }
                                
                                // For auditors (non-audited employees) or after reversal submitted, show as read-only text
                                if (!isAuditedEmployee || hasReversalSubmitted) {
                                    if (existingComment && existingComment.trim()) {
                                        const textDiv = document.createElement('div');
                                        textDiv.textContent = existingComment;
                                        textDiv.style.cssText = 'font-size: 0.5659rem; color: #4b5563; font-family: Poppins, sans-serif; white-space: pre-wrap; line-height: 1.6;';
                                        commentDiv.appendChild(textDiv);
                                    } else {
                                        const dash = document.createElement('span');
                                        dash.textContent = '-';
                                        dash.style.cssText = 'color: #9ca3af; font-style: italic; font-size: 0.5659rem;';
                                        commentDiv.appendChild(dash);
                                    }
                                } else {
                                    // For audited employees (before reversal), show input box
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.id = commentInputId;
                                    input.setAttribute('data-param-key', field.key);
                                    input.setAttribute('data-feedback-index', index);
                                    input.value = existingComment;
                                    input.placeholder = 'Enter your comment...';
                                    input.style.cssText = 'width: 100%; max-width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: Poppins, sans-serif; box-sizing: border-box;';
                                    // Save on both change and blur for real-time saving
                                    input.addEventListener('change', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    input.addEventListener('blur', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    commentDiv.appendChild(input);
                                }
                                
                                commentCell.appendChild(commentDiv);
                            });
                        } else {
                            const dash = document.createElement('span');
                            dash.textContent = '-';
                            dash.style.cssText = 'color: #9ca3af; font-style: italic;';
                            commentCell.appendChild(dash);
                        }
                        
                        row.appendChild(commentCell);
                    }
                }
            } else {
                // When hiding comments, keep 6 columns if audited employee (to match header with + Comment button)
                // Remove comment inputs but keep empty 6th column for alignment
                if (isAuditedEmployee) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.innerHTML = '';
                        }
                    } else if (row.children.length === 5) {
                        // Add empty column for alignment with header
                        const emptyCell = document.createElement('div');
                        row.appendChild(emptyCell);
                    }
                } else {
                    // Remove comment column if not audited employee
                    if (row.children.length === 6) {
                        row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                        const lastCell = row.lastElementChild;
                        if (lastCell) {
                            lastCell.remove();
                        }
                    }
                }
            }
        });
    }
}

// Save parameter comment from input box (local only, not to database)
function saveParameterComment(paramKey, feedbackIndex, commentText) {
    try {
        // Ensure currentUserEmail is available
        if (!currentUserEmail) {
            currentUserEmail = getCurrentUserEmail();
        }
        
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        if (!currentUserEmail) {
            alert('Error: User email not available. Please refresh the page.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Get existing comments array for this parameter or create new structure
        const paramComments = currentComments[paramKey] || {};
        const commentsArray = paramComments.comments || (paramComments.comment ? [paramComments.comment] : []);
        
        // Ensure array is large enough
        while (commentsArray.length <= feedbackIndex) {
            commentsArray.push('');
        }
        
        // Update the comment at the specific index
        commentsArray[feedbackIndex] = commentText.trim();
        
        // Update comment for this parameter (local only, not saved to database yet)
        const updatedComments = {
            ...currentComments,
            [paramKey]: {
                comments: commentsArray,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Update local audit object only (will be saved to database when reversal is submitted)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        console.log('Comment stored locally (will be saved on reversal submission)');
        
    } catch (error) {
        console.error('Error storing parameter comment locally:', error);
    }
}

// Make functions globally accessible
window.showParameterCommentModal = showParameterCommentModal;
window.closeParameterCommentModal = closeParameterCommentModal;
window.saveParameterCommentFromModal = saveParameterCommentFromModal;
window.toggleCommentsColumn = toggleCommentsColumn;
window.saveParameterComment = saveParameterComment;

// Acknowledge audit
async function acknowledgeAudit() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only acknowledge audits assigned to you.');
        return;
    }
    
    // Wait for confirmation dialog to be available
    if (!window.confirmationDialog) {
        // Wait a bit for it to initialize
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!window.confirmationDialog) {
            alert('Error: Confirmation dialog not available. Please refresh the page.');
            return;
        }
    }
    
    const result = await window.confirmationDialog.show({
        title: 'Acknowledge Audit',
        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
        confirmText: 'Acknowledge',
        cancelText: 'Cancel'
    });
    
    if (result) {
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        try {
            // Record acknowledgment in the database with correct fields
            const acknowledgementTime = new Date().toISOString();
            const { data, error } = await window.supabaseClient
                .from(currentTableName)
                .update({
                    acknowledgement_status: 'Acknowledged',
                    acknowledgement_status_updated_at: acknowledgementTime
                })
                .eq('id', currentAudit.id)
                .select();
            
            if (error) throw error;
            
            // Show success message
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Success',
                    message: '✓ Audit acknowledged. Thank you for your confirmation.',
                    confirmText: 'OK',
                    type: 'success'
                });
            } else {
            alert('✓ Audit acknowledged. Thank you for your confirmation.');
            }
            
            // Reload audit data to reflect changes
            loadAuditFromURL();
            
        } catch (error) {
            console.error('Error acknowledging audit:', error);
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Error',
                    message: 'Failed to record acknowledgment. Please try again.',
                    confirmText: 'OK',
                    type: 'error'
                });
            } else {
            alert('Failed to record acknowledgment. Please try again.');
            }
        }
    }
}

// Handle reversal form submission
document.addEventListener('DOMContentLoaded', function() {
    const reversalForm = document.getElementById('reversalForm');
    if (reversalForm) {
        reversalForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Verify that current user is the audited employee
            if (!isCurrentUserAuditedEmployee()) {
                alert('Error: You can only submit reversal requests for audits assigned to you.');
                return;
            }
            
            if (!currentAudit || !currentTableName) {
                alert('Error: Audit data not available');
                return;
            }
            
            // Check if Supabase client is initialized
            if (!window.supabaseClient) {
                alert('Error: Database connection not available. Please refresh the page and try again.');
                return;
            }
            
            // Validate required fields
            const reversalType = document.getElementById('reversalType').value;
            const reversalReason = document.getElementById('reversalReasonDropdown').value;
            
            if (!reversalType || !reversalReason) {
                alert('Please fill in all required fields (marked with *)');
                return;
            }
            
            // Get all parameters with comments (automatically included)
            // First, check database comments
            let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
            
            // Also check inline comment inputs in the DOM (real-time fallback)
            const inlineComments = {};
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    if (input.value && input.value.trim()) {
                        comments.push(input.value.trim());
                    }
                });
                if (comments.length > 0) {
                    inlineComments[field.key] = { comments: comments };
                }
            });
            
            // Merge inline comments (takes precedence if they exist)
            parameterComments = { ...parameterComments, ...inlineComments };
            
            // Find all parameters that have comments (check both formats)
            const parametersWithComments = currentErrorFields.filter(field => {
                const fieldComment = parameterComments[field.key];
                if (!fieldComment) return false;
                
                // Check for single comment format: {comment: "text"}
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    return true;
                }
                
                // Check for array format: {comments: ["text1", "text2"]}
                if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    return fieldComment.comments.some(c => c && c.trim());
                }
                
                return false;
            });
            
            if (parametersWithComments.length === 0) {
                alert('⚠ No parameter comments found. Please add comments using the comment icon next to each parameter\'s feedback before submitting a reversal request.');
                return;
            }
            
            // Build justification from parameter comments
            const selectedParameters = [];
            const justificationParts = [];
            
            parametersWithComments.forEach(field => {
                const fieldComment = parameterComments[field.key];
                let commentText = '';
                
                // Get comment text (handle both formats)
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    commentText = fieldComment.comment.trim();
                } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    // Join all comments with newlines
                    commentText = fieldComment.comments.filter(c => c && c.trim()).join('\n');
                }
                
                if (commentText) {
                    selectedParameters.push(field.label);
                    justificationParts.push(`${field.label}: ${commentText}`);
                }
            });
            
            const detailedJustification = justificationParts.join('\n\n');
            
            // Gather form data - use column names that match the database schema
            // Based on actual schema: fnchat_cfd table does NOT have reversal_status column
            // Status is tracked via reversal_approved and reversal_responded_at fields
            const reversalData = {
                reversal_requested_at: new Date().toISOString(),
                reversal_type: reversalType,
                // Combine reversal reason and detailed justification from parameter comments
                reversal_justification_from_agent: `${reversalReason}: ${detailedJustification}`,
                reversal_metrics_parameters: selectedParameters.join(', ') || null,
                within_auditor_scope: document.getElementById('withinAuditorScope').checked ? 'true' : 'false',
                score_before_appeal: currentAudit.average_score || currentAudit.averageScore || null,
                // Save parameter comments to database when reversal is submitted
                parameter_comments: parameterComments
                // Note: reversal_status column doesn't exist in the schema
                // Status is determined by reversal_approved (null = pending, 'true' = approved, 'false' = rejected)
                // reversal_responded_at is null until reviewed
            };
            
            // Don't set reversal_approved and reversal_responded_at to null explicitly
            // They will remain null by default if not set
            
            console.log('Submitting reversal request with data:', reversalData);
            console.log('Table name:', currentTableName);
            console.log('Audit ID:', currentAudit.id);
            
            // Helper function to retry database operations on schema cache errors
            async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    if (attempt > 0) {
                        // Wait longer on each retry (exponential backoff)
                        console.log(`Retrying database operation (attempt ${attempt + 1}/${maxRetries})...`);
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const result = await operation();
                    
                    // If no error, return success
                    if (!result.error) {
                        return result;
                    }
                    
                    // If it's a schema cache error, retry
                    if (result.error.message && (
                        result.error.message.includes('schema cache') ||
                        result.error.message.includes('Could not find') ||
                        result.error.message.includes('column') && result.error.message.includes('schema cache')
                    )) {
                        console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                        continue;
                    }
                    
                    // If it's not a schema cache error, return immediately
                    return result;
                }
                
                // Return last result after all retries exhausted
                return await operation();
            }
            
            try {
                // Update the audit record with reversal request (with retry logic for schema cache errors)
                const { data, error } = await retryOnSchemaCacheError(async () => {
                    return await window.supabaseClient
                        .from(currentTableName)
                        .update(reversalData)
                        .eq('id', currentAudit.id)
                        .select();
                });
                
                if (error) throw error;
                
                // Update currentAudit object immediately to reflect reversal submission
                if (currentAudit && data && data.length > 0) {
                    const updatedAudit = data[0];
                    currentAudit.reversalRequestedAt = updatedAudit.reversal_requested_at;
                    currentAudit.reversal_requested_at = updatedAudit.reversal_requested_at;
                    currentAudit.reversalType = updatedAudit.reversal_type;
                    currentAudit.reversal_type = updatedAudit.reversal_type;
                    currentAudit.reversalJustificationFromAgent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversal_justification_from_agent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversalMetricsParameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.reversal_metrics_parameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.withinAuditorScope = updatedAudit.within_auditor_scope;
                    currentAudit.within_auditor_scope = updatedAudit.within_auditor_scope;
                }
                
                // Show success dialog
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Success',
                        message: '✓ Reversal request submitted successfully!\n\nYour request will be reviewed by the quality team. You will be notified once a decision has been made.',
                        confirmText: 'OK',
                        type: 'success'
                    });
                } else {
                alert('✓ Reversal request submitted successfully!\n\nYour request will be reviewed by the quality team. You will be notified once a decision has been made.');
                }
                
                // Hide form and reload audit data
                toggleReversalForm();
                location.reload();
                
            } catch (error) {
                console.error('Error submitting reversal request:', error);
                console.error('Error details:', error.message, error);
                
                // Check if this is a schema cache or column error
                let errorMessage = error.message || 'Unknown error occurred';
                if (error.message && (
                    error.message.includes('schema cache') ||
                    error.message.includes('Could not find') ||
                    (error.message.includes('column') && error.message.includes('schema cache'))
                )) {
                    errorMessage = 'The database schema cache is being updated. Please wait a moment and try again. If the issue persists, the column may need to be added to the database table.';
                }
                
                // Provide more helpful error message
                let errorMsg = 'Failed to submit reversal request.\n\n';
                errorMsg += 'Error: ' + errorMessage + '\n\n';
                errorMsg += 'Please try again or contact support if the issue persists.';
                
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Error',
                        message: errorMsg,
                        confirmText: 'OK',
                        type: 'error'
                    });
                } else {
                    alert(errorMsg);
                }
            }
        });
    }
});
</script>

</body>
</html>

