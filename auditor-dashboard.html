<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Create Audit | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <style>
        .header-actions {
            display: flex;
            gap: 0.5625rem;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.4688rem 0.75rem;
            background-color: var(--background-white);
            color: var(--text-color);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            font-size: 0.6562rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family);
        }

        .action-btn:hover {
            background-color: var(--gray-50);
            border-color: var(--primary-color);
        }

        .action-btn.active {
            background-color: var(--primary-color);
            color: var(--white);
            border-color: var(--primary-color);
        }

        .action-btn svg {
            width: 0.75rem;
            height: 0.75rem;
        }

        /* Date Range Picker */
        .date-picker-dropdown {
            position: relative;
            display: inline-block;
        }

        .date-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.375rem;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 9.8438rem;
        }

        .date-dropdown-menu.active {
            display: block;
        }

        /* Filter Dropdown */
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-dropdown-menu {
            display: none;
            position: absolute;
            top: calc(100% + 0.375rem);
            left: 0;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 20rem;
            max-width: 90vw;
        }

        .filter-dropdown-menu.active {
            display: block;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .filter-label {
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .filter-input, .filter-select {
            padding: 0.375rem 0.5625rem;
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.2812rem;
            font-size: 0.6562rem;
            font-family: var(--font-family);
            background-color: var(--background-white);
            color: var(--text-color);
        }

        .filter-input:focus, .filter-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
    </style>

</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
    <p class="page-heading">Auditor's Dashboard</p>
    <div style="margin-bottom: 1.125rem; width: 100%;"></div>

        
            <!-- Tab Navigation -->
            <div style="position: relative; display: flex; background-color: var(--dark-forest); border-radius: 0.4688rem; overflow: hidden; width: 100%; max-width: 15rem; margin: 0.9375rem auto; padding: 0.2344rem; margin-top: 2rem;">
                <div style="position: absolute; top: 0.2344rem; height: calc(100% - 0.4688rem); background-color: var(--primary-color); border-radius: 0.2344rem; transition: all 0.3s ease; left: 0.2344rem; width: calc(50% - 0.2344rem);"></div>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" class="active" onclick="switchTab(this, 0)">Team Stats</button>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" onclick="switchTab(this, 1)">Standup View</button>
            </div>

    <!-- Action Buttons -->
    <div class="header-actions" style="margin-top: 1.125rem; margin-bottom: 1.125rem; justify-content: center;">
        <!-- Week Navigation -->
        <div style="display: flex; align-items: center; gap: 0.5625rem;">
            <button class="action-btn" id="prevWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Previous Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>
            <div class="action-btn" id="weekDisplay" style="padding: 0.4688rem 0.75rem; cursor: default; background-color: var(--primary-color); color: var(--white); border-color: var(--primary-color);">
                <span id="weekText">Week -</span>
            </div>
            <button class="action-btn" id="nextWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Next Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </button>
        </div>
        <!-- Date Range Picker -->
        <div class="date-picker-dropdown">
            <button class="action-btn" id="dateBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span id="dateBtnText">Date Range</span>
                <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div class="date-dropdown-menu" id="dateDropdown">
                <div class="filter-group">
                    <label class="filter-label">Start Date</label>
                    <input type="date" class="filter-input" id="startDate">
                </div>
                <div class="filter-group">
                    <label class="filter-label">End Date</label>
                    <input type="date" class="filter-input" id="endDate">
                </div>
                <div style="display: flex; gap: 0.375rem; margin-top: 0.375rem;">
                    <button class="action-btn" style="flex: 1;" onclick="applyDateFilter()">Apply</button>
                    <button class="action-btn" style="flex: 1;" onclick="clearDateFilter()">Clear</button>
                </div>
            </div>
        </div>
        <div class="filter-dropdown">
            <button class="action-btn" id="filterBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                </svg>
                <span>Filter</span>
            </button>
            <!-- Filter Dropdown Menu -->
            <div class="filter-dropdown-menu" id="filterDropdown">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5625rem; padding-bottom: 0.375rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <div style="font-size: 0.6562rem; font-weight: 600; color: #1A733E;">Filters</div>
                    <button onclick="clearFilters()" style="padding: 0.2812rem 0.5625rem; background-color: #f9fafb; color: #374151; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif; cursor: pointer;">Clear All</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr)); gap: 0.75rem;">
                    <!-- Status Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Status</label>
                        <select class="filter-input" id="statusFilter" onchange="applyFilters()">
                            <option value="">All Statuses</option>
                            <option value="pending">Pending</option>
                            <option value="in_progress">In Progress</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <!-- Channel Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Channel</label>
                        <select class="filter-input" id="channelFilter" onchange="applyFilters()">
                            <option value="">All Channels</option>
                        </select>
                    </div>
                    <!-- Auditor Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Auditor</label>
                        <select class="filter-input" id="auditorFilter" onchange="applyFilters()">
                            <option value="">All Auditors</option>
                        </select>
                    </div>
                    <!-- Employee Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Employee</label>
                        <select class="filter-input" id="employeeFilter" onchange="applyFilters()">
                            <option value="">All Employees</option>
                        </select>
                    </div>
                    <!-- Scorecard Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Scorecard</label>
                        <select class="filter-input" id="scorecardFilter" onchange="applyFilters()">
                            <option value="">All Scorecards</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

            <!-- stat Cards -->
            <div id="statsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(9rem, 1fr)); gap: 1.125rem; margin-bottom: 1.5rem; width: 100%;">
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat1Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Assigned</div>
                    <div id="stat1Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Completed</div>
                    <div id="completedCount" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="targetAchieved" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Remaining</div>
                    <div id="remainingCount" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat4Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">In Progress</div>
                    <div id="stat4Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat4Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat5Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Reversal Rate</div>
                    <div id="stat5Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat5Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;"></div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat6Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Avg Duration</div>
                    <div id="stat6Count" style="font-size: 1.875rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat6Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
            </div>


            <!-- Data Table -->
            <div id="performanceTable" style="background-color: var(--white); border-radius: 0.5625rem; box-shadow: 0 0.0469rem 0.1406rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; max-width: 80%; width: fit-content; min-width: 100%;">
                <div style="background-color: #f8f9fa; padding: 0.5625rem 0.75rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <h3 style="font-size: 0.8438rem; font-weight: 600; color: var(--text-color);">Progress Overview</h3>
                </div>
                <div style="padding: 0.75rem; overflow-x: auto;">
                    <div id="tableHeader" style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0 0.5625rem 0; font-weight: 700; font-size: 0.6562rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; min-width: fit-content;">
                        <div>Name</div>
                        <div>Assigned</div>
                        <div>Completed</div>
                        <div>Remaining</div>
                        <div>Avg Duration</div>
                        <div>Progress Meter</div>
                    </div>
                    <div id="performanceTableBody" style="min-width: fit-content;">
                        <div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>


<script>
// ============================================================================
// Global Variables
// ============================================================================
let currentTab = 0; // 0 = Team Stats, 1 = Standup View (removed Your Stats)
let allAssignments = [];
let unfilteredAssignments = []; // Store unfiltered data
let currentUserEmail = '';
let allUsers = [];
let currentFilters = {
    status: '',
    channel: '',
    auditor: '',
    employee: '',
    scorecard: ''
};
let allScorecards = [];
let currentWeek = null;
let currentWeekYear = null;
let dateFilter = { start: null, end: null };
let useWeekFilter = true;
let presenceChannel = null;
let onlineAuditors = new Set(); // Track online auditor emails
let heartbeatInterval = null;

// ============================================================================
// Initialize Page
// ============================================================================
document.addEventListener('DOMContentLoaded', async function() {
    await initializeDashboard();
    initializeSlider();
});

async function initializeDashboard() {
    try {
        // Wait for Supabase to be ready
        let attempts = 0;
        while (!window.supabaseClient && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            return;
        }

        // Get current user
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        currentUserEmail = userInfo.email;

        if (!currentUserEmail) {
            console.error('No user logged in');
            return;
        }

        // Initialize week filter
        initializeWeekFilter();
        setupEventListeners();

        // Load all users for lookups
        await loadAllUsers();
        
        // Load scorecards for filter
        await loadScorecards();
        
        // Load assignments and update dashboard
        await loadAssignments();
        
        // Setup presence tracking after everything is loaded
        await setupPresenceTracking();
        
    } catch (error) {
        console.error('Error initializing dashboard:', error);
    }
}

// ============================================================================
// Cache Helper Functions
// ============================================================================
function getCacheKey(prefix, userEmail, period = null) {
    const periodKey = period ? `${period.start}_${period.end}` : 'default';
    return `auditor_dashboard_cache_${prefix}_${userEmail}_${periodKey}`;
}

function getCachedData(cacheKey) {
    try {
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;
        
        const { data, timestamp } = JSON.parse(cached);
        return data;
    } catch (e) {
        console.warn('Error reading cache:', e);
        return null;
    }
}

function setCachedData(cacheKey, data) {
    try {
        localStorage.setItem(cacheKey, JSON.stringify({
            data,
            timestamp: Date.now()
        }));
    } catch (e) {
        console.warn('Error writing cache:', e);
        // If storage is full, clear old cache entries
        if (e.name === 'QuotaExceededError') {
            clearOldCache();
            // Try once more
            try {
                localStorage.setItem(cacheKey, JSON.stringify({
                    data,
                    timestamp: Date.now()
                }));
            } catch (e2) {
                console.error('Failed to cache after cleanup:', e2);
            }
        }
    }
}

function clearOldCache() {
    try {
        const keys = Object.keys(localStorage);
        const cacheKeys = keys.filter(k => k.startsWith('auditor_dashboard_cache_'));
        
        // Keep only the most recent cache for each prefix/user combination
        const cacheGroups = {};
        cacheKeys.forEach(key => {
            const parts = key.split('_');
            if (parts.length >= 5) {
                const prefix = parts[3];
                const userEmail = parts[4];
                const groupKey = `${prefix}_${userEmail}`;
                if (!cacheGroups[groupKey]) {
                    cacheGroups[groupKey] = [];
                }
                cacheGroups[groupKey].push(key);
            }
        });
        
        // For each group, keep only the most recent entry
        Object.values(cacheGroups).forEach(group => {
            if (group.length > 1) {
                // Sort by timestamp and keep only the newest
                const withTimestamps = group.map(key => {
                    try {
                        const cached = localStorage.getItem(key);
                        if (cached) {
                            const { timestamp } = JSON.parse(cached);
                            return { key, timestamp };
                        }
                    } catch (e) {
                        return { key, timestamp: 0 };
                    }
                }).sort((a, b) => b.timestamp - a.timestamp);
                
                // Remove all but the newest
                withTimestamps.slice(1).forEach(({ key }) => {
                    localStorage.removeItem(key);
                });
            }
        });
    } catch (e) {
        console.warn('Error clearing old cache:', e);
    }
}

function invalidateAuditorDashboardCache(userEmail = null) {
    try {
        const keys = Object.keys(localStorage);
        const cacheKeys = keys.filter(k => k.startsWith('auditor_dashboard_cache_'));
        
        if (userEmail) {
            // Invalidate only for specific user
            cacheKeys.forEach(key => {
                if (key.includes(userEmail)) {
                    localStorage.removeItem(key);
                }
            });
        } else {
            // Invalidate all auditor dashboard cache
            cacheKeys.forEach(key => localStorage.removeItem(key));
        }
    } catch (e) {
        console.warn('Error invalidating cache:', e);
    }
}

// Get current period dates (week or date range)
function getCurrentPeriodDates() {
    if (dateFilter.start || dateFilter.end) {
        // Using date range filter
        return {
            start: dateFilter.start ? new Date(dateFilter.start) : new Date(0),
            end: dateFilter.end ? new Date(dateFilter.end) : new Date()
        };
    } else if (useWeekFilter && currentWeek !== null) {
        // Using week filter
        return getWeekDates(currentWeek, currentWeekYear);
    } else {
        // Default to current week
        const today = new Date();
        return getWeekDates(getWeekNumber(today), today.getFullYear());
    }
}

// ============================================================================
// Load Data
// ============================================================================
async function loadAllUsers() {
    try {
        // Use sessionStorage cache for users (5 minutes cache, same as home.html)
        const cachedUsers = sessionStorage.getItem('cachedUsers');
        const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
        const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
        
        if (cachedUsers && cacheAge < 300000) { // 5 minutes cache
            allUsers = JSON.parse(cachedUsers);
            console.log(`Loaded ${allUsers.length} users from cache`);
        } else {
            const { data, error } = await window.supabaseClient
                .from('users')
                .select('email, name, role, channel, quality_mentor')
                .eq('is_active', true);
            
            if (error) throw error;
            
            allUsers = data || [];
            console.log(`Loaded ${allUsers.length} users`);
            
            // Cache users in sessionStorage
            sessionStorage.setItem('cachedUsers', JSON.stringify(allUsers));
            sessionStorage.setItem('cachedUsersTime', Date.now().toString());
        }
        
    } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
    }
}

async function loadScorecards() {
    try {
        const cacheKey = getCacheKey('scorecards', currentUserEmail, null);
        
        // Check cache first and render immediately
        const cachedScorecards = getCachedData(cacheKey);
        if (cachedScorecards) {
            console.log('Rendering cached scorecards immediately');
            allScorecards = cachedScorecards;
            populateScorecardFilter();
        }
        
        // Always fetch fresh data in background
        const { data, error } = await window.supabaseClient
            .from('scorecards')
            .select('id, name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        allScorecards = data || [];
        
        // Cache the fresh data
        setCachedData(cacheKey, allScorecards);
        
        // Update UI with fresh data
        console.log('Updating UI with fresh scorecards');
        populateScorecardFilter();
        
    } catch (error) {
        console.error('Error loading scorecards:', error);
        allScorecards = [];
    }
}

async function loadAssignments() {
    try {
        const period = getCurrentPeriodDates();
        const cacheKey = getCacheKey('assignments', currentUserEmail, period);
        
        // Check cache first and render immediately
        const cachedAssignments = getCachedData(cacheKey);
        if (cachedAssignments) {
            console.log('Rendering cached assignments immediately');
            allAssignments = cachedAssignments;
            unfilteredAssignments = [...allAssignments];
            
            // Populate filters
            populateChannelFilter();
            populateAuditorFilter();
            populateEmployeeFilter();
            
            // Update dashboard based on current tab
            await updateDashboard();
        }
        
        // Always fetch fresh data in background
        fetchAndCacheAssignments(cacheKey, period);
        
    } catch (error) {
        console.error('Error loading assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
    }
}

async function fetchAndCacheAssignments(cacheKey, period) {
    try {
        const { data, error } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .eq('auditor_email', currentUserEmail)
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        allAssignments = data || [];
        unfilteredAssignments = [...allAssignments]; // Store unfiltered copy
        console.log(`Loaded ${allAssignments.length} assignments`);
        
        // Cache the fresh data
        setCachedData(cacheKey, allAssignments);
        
        // Populate filters
        populateChannelFilter();
        populateAuditorFilter();
        populateEmployeeFilter();
        
        // Update UI with fresh data
        console.log('Updating UI with fresh assignments');
        await updateDashboard();
        
    } catch (error) {
        console.error('Error fetching assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
    }
}

// ============================================================================
// Update Dashboard
// ============================================================================
async function updateDashboard() {
    if (currentTab === 0) {
        // Team Stats
        await updateTeamStats();
    } else if (currentTab === 1) {
        // Standup View
        await updateStandupView();
    }
}

// Note: updateYourStats() function has been moved to create-audit.html

async function updateTeamStats() {
    // Only proceed if we're still on Team Stats tab
    if (currentTab !== 0) {
        return;
    }
    
    const period = getCurrentPeriodDates();
    const filterKey = JSON.stringify(currentFilters);
    const cacheKey = getCacheKey('teamStats', currentUserEmail, period) + '_' + btoa(filterKey).slice(0, 20);
    
    // Check cache first and render immediately (only if still on Team Stats tab)
    const cachedStats = getCachedData(cacheKey);
    if (cachedStats && currentTab === 0) {
        console.log('Rendering cached team stats immediately');
        renderTeamStats(cachedStats);
        // Update online status indicators after rendering
        setTimeout(() => updateOnlineStatusIndicators(), 100);
    }
    
    // Always fetch fresh data in background
    fetchAndCacheTeamStats(cacheKey, period);
}

async function fetchAndCacheTeamStats(cacheKey, period) {
    // Get all Quality Analysts (auditors)
    const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
    
    if (qualityAnalysts.length === 0) {
        const tableBody = document.getElementById('performanceTableBody');
        tableBody.innerHTML = `
            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                No Quality Analysts found in the system.
            </div>
        `;
        
        // Reset stats
        document.getElementById('stat1Label').textContent = 'ASSIGNED';
        document.getElementById('stat1Count').textContent = '0';
        document.getElementById('completedCount').textContent = '0';
        document.getElementById('targetAchieved').textContent = '-';
        document.getElementById('remainingCount').textContent = '0';
        document.getElementById('stat4Label').textContent = 'IN PROGRESS';
        document.getElementById('stat4Count').textContent = '0';
        document.getElementById('stat4Subtitle').textContent = '-';
        document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
        document.getElementById('stat5Count').textContent = '0';
        return;
    }
    
    // Load all assignments for all Quality Analysts
    try {
        const { data, error } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .in('auditor_email', qualityAnalysts.map(qa => qa.email))
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        const teamAssignments = data || [];
        
        // Calculate overall team stats
        const totalAssigned = teamAssignments.length;
        const completed = teamAssignments.filter(a => a.status === 'completed').length;
        const inProgress = teamAssignments.filter(a => a.status === 'in_progress').length;
        const pending = teamAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        
        // Calculate team average audit duration
        let avgDuration = 0;
        let avgDurationText = '-';
        let avgDurationSubtitle = 'per audit';
        
        try {
            // Get all scorecards to query audit tables
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                let totalDuration = 0; // Total in minutes
                let auditCount = 0;
                
                // Query each scorecard table for audits by team members
                for (const scorecard of scorecards) {
                    try {
                        const { data: audits, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('audit_duration')
                            .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                            .not('audit_duration', 'is', null);
                        
                        if (!error && audits) {
                            audits.forEach(audit => {
                                // Handle duration conversion (new format: seconds, legacy format: minutes)
                                let durationInMinutes = 0;
                                if (typeof audit.audit_duration === 'number') {
                                    const value = audit.audit_duration;
                                    // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
                                    // Otherwise, assume it's already in minutes (legacy format)
                                    if (value >= 1440) {
                                        durationInMinutes = value / 60; // Convert seconds to minutes
                                    } else {
                                        durationInMinutes = value; // Already in minutes
                                    }
                                } else if (typeof audit.audit_duration === 'string') {
                                    const asInt = parseInt(audit.audit_duration);
                                    if (!isNaN(asInt)) {
                                        if (asInt >= 1440) {
                                            durationInMinutes = asInt / 60; // Convert seconds to minutes
                                        } else {
                                            durationInMinutes = asInt; // Already in minutes
                                        }
                                    }
                                }
                                
                                if (durationInMinutes > 0) {
                                    totalDuration += durationInMinutes;
                                    auditCount++;
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Error getting duration from ${scorecard.table_name}:`, err);
                    }
                }
                
                if (auditCount > 0) {
                    avgDuration = totalDuration / auditCount; // Average in minutes
                    
                    // Format duration (avgDuration is in minutes)
                    if (avgDuration >= 60) {
                        const hours = Math.floor(avgDuration / 60);
                        const minutes = Math.round(avgDuration % 60);
                        avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                    } else {
                        avgDurationText = `${Math.round(avgDuration)}m`;
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating team average duration:', error);
        }
        
        // Calculate reversal count for team
        let teamReversalCount = 0;
        try {
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                for (const scorecard of scorecards) {
                    try {
                        const { data, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('id')
                            .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                            .not('reversal_requested_at', 'is', null);
                        
                        if (!error && data) {
                            teamReversalCount += data.length;
                        }
                    } catch (err) {
                        console.warn(`Error counting team reversals in ${scorecard.table_name}:`, err);
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating team reversal count:', error);
        }
        
        console.log('Team Stats - Reversal count:', teamReversalCount);
        
        // Calculate stats for each Quality Analyst
        const auditorStats = [];
        for (const qa of qualityAnalysts) {
            const qaAssignments = teamAssignments.filter(a => a.auditor_email === qa.email);
            const qaCompleted = qaAssignments.filter(a => a.status === 'completed').length;
            const qaInProgress = qaAssignments.filter(a => a.status === 'in_progress').length;
            const qaPending = qaAssignments.filter(a => a.status === 'pending').length;
            const qaRemaining = qaPending + qaInProgress;
            const qaPercentage = qaAssignments.length > 0 ? Math.round((qaCompleted / qaAssignments.length) * 100) : 0;
            
            // Calculate average duration for this auditor
            let avgDurationText = '-';
            try {
                const { data: scorecards, error: scError } = await window.supabaseClient
                    .from('scorecards')
                    .select('table_name')
                    .eq('is_active', true);
                
                if (!scError && scorecards) {
                    let totalDuration = 0; // Total in minutes
                    let auditCount = 0;
                    
                    // Query each scorecard table for audits by this auditor
                    for (const scorecard of scorecards) {
                        try {
                            const { data: audits, error } = await window.supabaseClient
                                .from(scorecard.table_name)
                                .select('audit_duration')
                                .eq('auditor_email', qa.email)
                                .not('audit_duration', 'is', null);
                            
                            if (!error && audits) {
                                audits.forEach(audit => {
                                    // Handle duration conversion (new format: seconds, legacy format: minutes)
                                    let durationInMinutes = 0;
                                    if (typeof audit.audit_duration === 'number') {
                                        const value = audit.audit_duration;
                                        // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
                                        // Otherwise, assume it's already in minutes (legacy format)
                                        if (value >= 1440) {
                                            durationInMinutes = value / 60; // Convert seconds to minutes
                                        } else {
                                            durationInMinutes = value; // Already in minutes
                                        }
                                    } else if (typeof audit.audit_duration === 'string') {
                                        const asInt = parseInt(audit.audit_duration);
                                        if (!isNaN(asInt)) {
                                            if (asInt >= 1440) {
                                                durationInMinutes = asInt / 60; // Convert seconds to minutes
                                            } else {
                                                durationInMinutes = asInt; // Already in minutes
                                            }
                                        }
                                    }
                                    
                                    if (durationInMinutes > 0) {
                                        totalDuration += durationInMinutes;
                                        auditCount++;
                                    }
                                });
                            }
                        } catch (err) {
                            console.warn(`Error getting duration from ${scorecard.table_name} for ${qa.email}:`, err);
                        }
                    }
                    
                    if (auditCount > 0) {
                        const avgDuration = totalDuration / auditCount; // Average in minutes
                        
                        // Format duration (avgDuration is in minutes)
                        if (avgDuration >= 60) {
                            const hours = Math.floor(avgDuration / 60);
                            const minutes = Math.round(avgDuration % 60);
                            avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        } else {
                            avgDurationText = `${Math.round(avgDuration)}m`;
                        }
                    }
                }
            } catch (error) {
                console.error(`Error calculating average duration for ${qa.email}:`, error);
            }
            
            auditorStats.push({
                name: qa.name || qa.email,
                email: qa.email,
                assigned: qaAssignments.length,
                completed: qaCompleted,
                remaining: qaRemaining,
                percentage: qaPercentage,
                avgDuration: avgDurationText,
                isCurrentUser: qa.email === currentUserEmail
            });
        }
        
        // Sort by assigned count (descending) and then by name
        auditorStats.sort((a, b) => {
            if (b.assigned !== a.assigned) {
                return b.assigned - a.assigned;
            }
            return a.name.localeCompare(b.name);
        });
        
        // Cache the computed stats
        const statsData = {
            totalAssigned,
            completed,
            inProgress,
            pending,
            remaining,
            percentage,
            avgDurationText,
            avgDurationSubtitle,
            teamReversalCount,
            auditorStats,
            qualityAnalystsCount: qualityAnalysts.length
        };
        setCachedData(cacheKey, statsData);
        
        // Update UI with fresh data (only if still on Team Stats tab)
        if (currentTab === 0) {
            console.log('Updating UI with fresh team stats');
            renderTeamStats(statsData);
            // Update online status indicators after rendering
            setTimeout(() => updateOnlineStatusIndicators(), 100);
        } else {
            console.log('Skipping team stats render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading team stats:', error);
    }
}

function renderTeamStats(statsData) {
    const {
        totalAssigned,
        completed,
        inProgress,
        remaining,
        percentage,
        avgDurationText,
        avgDurationSubtitle,
        teamReversalCount,
        auditorStats,
        qualityAnalystsCount
    } = statsData;
    
    // Get all Quality Analysts (auditors)
    const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
    const qualityAnalystsLength = qualityAnalystsCount || qualityAnalysts.length;
    
    if (qualityAnalysts.length === 0) {
        const tableBody = document.getElementById('performanceTableBody');
        tableBody.innerHTML = `
            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                No Quality Analysts found in the system.
            </div>
        `;
        
        // Reset stats
        document.getElementById('stat1Label').textContent = 'ASSIGNED';
        document.getElementById('stat1Count').textContent = '0';
        document.getElementById('completedCount').textContent = '0';
        document.getElementById('targetAchieved').textContent = '-';
        document.getElementById('remainingCount').textContent = '0';
        document.getElementById('stat4Label').textContent = 'IN PROGRESS';
        document.getElementById('stat4Count').textContent = '0';
        document.getElementById('stat4Subtitle').textContent = '-';
        document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
        document.getElementById('stat5Count').textContent = '0';
        return;
    }
    
    // Show the 4th and 6th stat cards (in case they were hidden in standup view)
    const stat4Card = document.getElementById('stat4Count').closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        stat4Card.style.display = 'flex';
        // Remove progress bar if it exists
        const progressBar = stat4Card.querySelector('.progress-bar-container');
        if (progressBar) progressBar.remove();
    }
    
    const stat6Card = document.getElementById('stat6Count').closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'flex';
    }
    
    // Reset 3rd card label to REMAINING and remove progress bar
    const remainingCard = document.querySelector('#remainingCount').closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const label = remainingCard.querySelector('div[style*="font-size: 0.6562rem"]');
        if (label) label.textContent = 'REMAINING';
        
        // Remove progress bar if it exists
        const progressBar = remainingCard.querySelector('.progress-bar-container');
        if (progressBar) progressBar.remove();
    }
    
    // Update stat cards with team stats
    document.getElementById('stat1Label').textContent = 'ASSIGNED';
    document.getElementById('stat1Count').textContent = totalAssigned;
    document.getElementById('completedCount').textContent = completed;
    document.getElementById('targetAchieved').textContent = `${percentage}% Team Target Achieved`;
    
    const remainingCount = document.getElementById('remainingCount');
    remainingCount.style.fontSize = '2.625rem';
    remainingCount.textContent = remaining;
    
    document.getElementById('stat4Label').textContent = 'IN PROGRESS';
    const stat4Count = document.getElementById('stat4Count');
    stat4Count.style.fontSize = '2.625rem';
    stat4Count.textContent = inProgress;
    document.getElementById('stat4Subtitle').textContent = `${qualityAnalystsLength} auditor${qualityAnalystsLength !== 1 ? 's' : ''}`;
    document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
    document.getElementById('stat5Count').textContent = teamReversalCount;
    document.getElementById('stat5Subtitle').textContent = '';
    document.getElementById('stat6Label').textContent = 'AVG DURATION';
    document.getElementById('stat6Count').textContent = avgDurationText;
    document.getElementById('stat6Subtitle').textContent = avgDurationSubtitle;
    
    // Update table header
    const tableHeader = document.getElementById('tableHeader');
    tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr)';
    tableHeader.style.display = 'grid';
    tableHeader.style.gap = '0.75rem';
    tableHeader.style.alignItems = 'center';
    tableHeader.innerHTML = `
        <div>Name</div>
        <div>Assigned</div>
        <div>Completed</div>
        <div>Remaining</div>
        <div>Avg Duration</div>
        <div>Progress Meter</div>
    `;
    
    // Update table with all Quality Analysts
    const tableBody = document.getElementById('performanceTableBody');
    tableBody.innerHTML = auditorStats.map(stats => `
        <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6; ${stats.isCurrentUser ? 'background-color: #f0fdf4;' : ''}" data-auditor-email="${escapeHtml(stats.email)}">
            <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600; display: flex; align-items: center;" data-label="Name">
                ${escapeHtml(stats.name)}${stats.isCurrentUser ? ' <span style="color: var(--primary-color); font-size: 0.5625rem;">(You)</span>' : ''}
                ${onlineAuditors.has(stats.email) ? '<span class="online-indicator" style="display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);" title="Online"></span>' : ''}
            </div>
            <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Assigned">${stats.assigned}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Completed">${stats.completed}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Remaining">${stats.remaining}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Avg Duration">${stats.avgDuration}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Progress">
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage}%</span>
                    <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative;">
                        <div style="height: 100%; width: ${stats.percentage}%; background-color: var(--primary-color); transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
    
    // Update online status indicators after rendering
    setTimeout(() => updateOnlineStatusIndicators(), 100);
}

async function updateStandupView() {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    // Update UI structure immediately (cards, table headers) - instant feedback
    renderStandupViewStructure();
    
    const period = getCurrentPeriodDates();
    const cacheKey = getCacheKey('standupView', currentUserEmail, period);
    
    // Check cache first and render immediately (only if still on Standup View tab)
    const cachedStandupData = getCachedData(cacheKey);
    if (cachedStandupData && currentTab === 1) {
        console.log('Rendering cached standup view immediately');
        renderStandupViewData(cachedStandupData);
    }
    
    // Always fetch fresh data in background
    fetchAndCacheStandupView(cacheKey);
}

// Render the UI structure immediately (cards, table headers) - no data needed
function renderStandupViewStructure() {
    // Update table header for standup view immediately
    const tableHeader = document.getElementById('tableHeader');
    if (tableHeader) {
        tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr)';
        tableHeader.style.display = 'grid';
        tableHeader.style.gap = '0.75rem';
        tableHeader.style.alignItems = 'center';
        tableHeader.innerHTML = `
            <div>Channel</div>
            <div>Assigned</div>
            <div>Completed</div>
            <div>Remaining</div>
            <div>Progress Meter</div>
        `;
    }
    
    // Show loading state in table body
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>';
    }
    
    // Update card labels immediately (values will be updated when data loads)
    const stat1Label = document.getElementById('stat1Label');
    if (stat1Label) stat1Label.textContent = 'ASSIGNED';
    
    // Update 3rd card to COVERAGE
    const remainingCard = document.querySelector('#remainingCount')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const label = remainingCard.querySelector('div[style*="font-size: 0.6562rem"]');
        if (label) label.textContent = 'COVERAGE';
    }
    
    // Update 4th card to PASSING RATE
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        stat4Card.style.display = 'flex';
        const label = stat4Card.querySelector('#stat4Label');
        if (label) label.textContent = 'PASSING RATE';
    }
    
    // Update 5th card to REVERSALS
    const stat5Label = document.getElementById('stat5Label');
    if (stat5Label) stat5Label.textContent = 'REVERSALS';
    
    // Hide 6th card (AVG DURATION)
    const stat6Card = document.getElementById('stat6Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'none';
    }
}

// Render standup view data (called with cached or fresh data)
function renderStandupViewData(standupData) {
    const {
        totalAssigned,
        completed,
        percentage,
        coveragePercent,
        passingRate,
        standupReversalCount,
        channelStats
    } = standupData;
    
    // Update stat cards
    const stat1Count = document.getElementById('stat1Count');
    if (stat1Count) stat1Count.textContent = totalAssigned || 0;
    
    const completedCount = document.getElementById('completedCount');
    if (completedCount) completedCount.textContent = completed || 0;
    
    const targetAchieved = document.getElementById('targetAchieved');
    if (targetAchieved) targetAchieved.textContent = `${percentage || 0}% Target Achieved`;
    
    // Update 3rd card to COVERAGE with progress bar
    const remainingCard = document.querySelector('#remainingCount')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const countDiv = remainingCard.querySelector('#remainingCount');
        if (countDiv) {
            countDiv.style.fontSize = '2.625rem';
            countDiv.textContent = (coveragePercent || 0) + '%';
            
            // Add/update progress bar
            let progressContainer = remainingCard.querySelector('.progress-bar-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
                countDiv.parentElement.appendChild(progressContainer);
            }
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${coveragePercent || 0}%;"></div>`;
        }
    }
    
    // Update 4th card to PASSING RATE with progress bar
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        const countDiv = stat4Card.querySelector('#stat4Count');
        if (countDiv) {
            countDiv.style.fontSize = '2.625rem';
            countDiv.textContent = (passingRate || 0) + '%';
            
            const subtitle = stat4Card.querySelector('#stat4Subtitle');
            if (subtitle) subtitle.textContent = '';
            
            // Add/update progress bar
            let progressContainer = stat4Card.querySelector('.progress-bar-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
                countDiv.parentElement.appendChild(progressContainer);
            }
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${passingRate || 0}%;"></div>`;
        }
    }
    
    // Update 5th card to REVERSALS
    const stat5Count = document.getElementById('stat5Count');
    if (stat5Count) stat5Count.textContent = standupReversalCount || 0;
    
    const stat5Subtitle = document.getElementById('stat5Subtitle');
    if (stat5Subtitle) stat5Subtitle.textContent = '';
    
    // Update table with channel statistics
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        if (!channelStats || Object.keys(channelStats).length === 0) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No channel data available</div>';
        } else {
            const sortedChannels = Object.keys(channelStats).sort();
            tableBody.innerHTML = sortedChannels.map(channel => {
                const stats = channelStats[channel];
                
                return `
                    <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6;">
                        <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600;" data-label="Channel">${escapeHtml(channel)}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Assigned">${stats.assigned || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Completed">${stats.completed || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Remaining">${stats.remaining || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Progress">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage || 0}%</span>
                                <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative;">
                                    <div style="height: 100%; background: var(--success-color); border-radius: 0.2812rem; transition: width 0.3s ease; width: ${stats.percentage || 0}%;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }
}

async function fetchAndCacheStandupView(cacheKey) {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    try {
        // Load all audit assignments (same as Team Stats)
        const { data, error } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        const allAuditAssignments = data || [];
        
        // Calculate overall stats
        const totalAssigned = allAuditAssignments.length;
        const completed = allAuditAssignments.filter(a => a.status === 'completed').length;
        const inProgress = allAuditAssignments.filter(a => a.status === 'in_progress').length;
        const pending = allAuditAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        
        // Calculate average audit duration from completed audits
        let avgDuration = 0;
        let avgDurationText = '-';
        let avgDurationSubtitle = 'per audit';
        
        try {
            // Get all scorecards to query audit tables
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                let totalDuration = 0; // Total in minutes
                let auditCount = 0;
                
                // Query each scorecard table for all audits
                for (const scorecard of scorecards) {
                    try {
                        const { data: audits, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('audit_duration')
                            .not('audit_duration', 'is', null);
                        
                        if (!error && audits) {
                            audits.forEach(audit => {
                                // Handle duration conversion (new format: seconds, legacy format: minutes)
                                let durationInMinutes = 0;
                                if (typeof audit.audit_duration === 'number') {
                                    const value = audit.audit_duration;
                                    // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
                                    // Otherwise, assume it's already in minutes (legacy format)
                                    if (value >= 1440) {
                                        durationInMinutes = value / 60; // Convert seconds to minutes
                                    } else {
                                        durationInMinutes = value; // Already in minutes
                                    }
                                } else if (typeof audit.audit_duration === 'string') {
                                    const asInt = parseInt(audit.audit_duration);
                                    if (!isNaN(asInt)) {
                                        if (asInt >= 1440) {
                                            durationInMinutes = asInt / 60; // Convert seconds to minutes
                                        } else {
                                            durationInMinutes = asInt; // Already in minutes
                                        }
                                    }
                                }
                                
                                if (durationInMinutes > 0) {
                                    totalDuration += durationInMinutes;
                                    auditCount++;
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Error getting duration from ${scorecard.table_name}:`, err);
                    }
                }
                
                if (auditCount > 0) {
                    avgDuration = totalDuration / auditCount; // Average in minutes
                    
                    // Format duration (avgDuration is in minutes)
                    if (avgDuration >= 60) {
                        const hours = Math.floor(avgDuration / 60);
                        const minutes = Math.round(avgDuration % 60);
                        avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                    } else {
                        avgDurationText = `${Math.round(avgDuration)}m`;
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating average duration:', error);
        }
        
        // Calculate coverage percentage
        const coveragePercent = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        
        // Calculate passing rate from all audits (matching expert-audits.html logic)
        let passingRate = 0;
        let totalAudits = 0;
        let passedAudits = 0;
        
        try {
            // Get all scorecard tables
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards && scorecards.length > 0) {
                // Query all scorecard tables for audits
                for (const scorecard of scorecards) {
                    try {
                        const { data: audits, error: auditError } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('passing_status');
                        
                        if (!auditError && audits && audits.length > 0) {
                            audits.forEach(audit => {
                                totalAudits++;
                                const passingStatus = audit.passing_status || audit.passingStatus;
                                const normalizedStatus = normalizePassingStatus(passingStatus);
                                if (normalizedStatus === 'Passed') {
                                    passedAudits++;
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Error loading audits from ${scorecard.table_name}:`, err);
                    }
                }
                
                // Calculate pass rate (matching expert-audits.html: passed / total * 100)
                if (totalAudits > 0) {
                    passingRate = Math.round((passedAudits / totalAudits) * 100);
                }
            }
        } catch (error) {
            console.error('Error calculating passing rate:', error);
        }
        
        // Calculate reversal count for all audits
        let standupReversalCount = 0;
        try {
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                for (const scorecard of scorecards) {
                    try {
                        const { data, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('id')
                            .not('reversal_requested_at', 'is', null);
                        
                        if (!error && data) {
                            standupReversalCount += data.length;
                        }
                    } catch (err) {
                        console.warn(`Error counting reversals in ${scorecard.table_name}:`, err);
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating reversal count:', error);
        }
        
        console.log('Standup View - Reversal count:', standupReversalCount);
        
        // Group assignments by channel
        const channelStats = {};
        
        allAuditAssignments.forEach(assignment => {
            // Find the employee to get their channel
            const emp = allUsers.find(u => u.email === assignment.employee_email);
            const channel = emp?.channel || 'Unknown';
            
            if (!channelStats[channel]) {
                channelStats[channel] = {
                    assigned: 0,
                    completed: 0,
                    inProgress: 0,
                    pending: 0,
                    remaining: 0,
                    percentage: 0
                };
            }
            
            channelStats[channel].assigned++;
            
            if (assignment.status === 'completed') {
                channelStats[channel].completed++;
            } else if (assignment.status === 'in_progress') {
                channelStats[channel].inProgress++;
            } else if (assignment.status === 'pending') {
                channelStats[channel].pending++;
            }
        });
        
        // Calculate remaining and percentage for each channel
        Object.keys(channelStats).forEach(channel => {
            const stats = channelStats[channel];
            stats.remaining = stats.pending + stats.inProgress;
            stats.percentage = stats.assigned > 0 ? Math.round((stats.completed / stats.assigned) * 100) : 0;
        });
        
        // Cache the computed data
        const standupData = {
            totalAssigned,
            completed,
            percentage,
            coveragePercent,
            passingRate,
            standupReversalCount,
            channelStats
        };
        setCachedData(cacheKey, standupData);
        
        // Update UI with fresh data (only if still on Standup View tab)
        if (currentTab === 1) {
            console.log('Updating UI with fresh standup view data');
            renderStandupViewData(standupData);
        } else {
            console.log('Skipping standup view render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading standup view:', error);
        // Show error in table
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && currentTab === 1) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading data. Please try again.</div>';
        }
    }
}

// ============================================================================
// Tab Switching
// ============================================================================
    async function switchTab(tabElement, index) {
    currentTab = index;
    
        const tabs = document.querySelectorAll('button[onclick*="switchTab"]');
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        // Remove active class from all tabs
        tabs.forEach(tab => tab.classList.remove('active'));
        // Add active class to clicked tab
        tabElement.classList.add('active');
        
        // Calculate position based on tab index and container width
        const containerPadding = 5; // 0.2344rem = 0.1758rem
        const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
        const sliderLeft = containerPadding + (index * tabWidth);
        
        slider.style.left = `${sliderLeft}px`;
        slider.style.width = `${tabWidth}px`;
        
    // Update dashboard based on tab
    await updateDashboard();
}

// ============================================================================
// Initialize Slider
// ============================================================================
function initializeSlider() {
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        if (slider && tabBar) {
            // Disable transition for initial positioning
            slider.style.transition = 'none';
            
            // Calculate position for first tab (index 0)
            const containerPadding = 5; // 0.2344rem = 0.1758rem
            const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
            const sliderLeft = containerPadding + (0 * tabWidth); // First tab
            
            slider.style.left = `${sliderLeft}px`;
            slider.style.width = `${tabWidth}px`;
            
            // Re-enable transition after positioning
            requestAnimationFrame(() => {
                slider.style.transition = 'all 0.3s ease';
            });
        }
}

// ============================================================================
// Filter Functions
// ============================================================================
function toggleFilters() {
    const dropdown = document.getElementById('filterDropdown');
    const filterBtn = document.getElementById('filterBtn');
    if (dropdown && filterBtn) {
        dropdown.classList.toggle('active');
        filterBtn.classList.toggle('active');
    }
}

function populateChannelFilter() {
    const channelFilter = document.getElementById('channelFilter');
    if (!channelFilter) return;
    
    // Get unique channels from all users
    const uniqueChannels = [...new Set(allUsers.map(u => u.channel).filter(Boolean))];
    
    // Clear existing options except "All Channels"
    const existingValue = channelFilter.value;
    channelFilter.innerHTML = '<option value="">All Channels</option>';
    
    // Add channel options
    uniqueChannels.sort().forEach(channel => {
        const option = document.createElement('option');
        option.value = channel;
        option.textContent = channel;
        channelFilter.appendChild(option);
    });
    
    if (existingValue) channelFilter.value = existingValue;
}

function populateAuditorFilter() {
    const auditorFilter = document.getElementById('auditorFilter');
    if (!auditorFilter) return;
    
    // Get all Quality Analysts (auditors)
    const auditors = allUsers.filter(u => u.role === 'Quality Analyst');
    
    const existingValue = auditorFilter.value;
    auditorFilter.innerHTML = '<option value="">All Auditors</option>';
    
    auditors.sort((a, b) => (a.name || a.email).localeCompare(b.name || b.email)).forEach(auditor => {
        const option = document.createElement('option');
        option.value = auditor.email;
        option.textContent = auditor.name || auditor.email;
        auditorFilter.appendChild(option);
    });
    
    if (existingValue) auditorFilter.value = existingValue;
}

function populateEmployeeFilter() {
    const employeeFilter = document.getElementById('employeeFilter');
    if (!employeeFilter) return;
    
    // Get unique employees from assignments
    const employeeEmails = [...new Set(unfilteredAssignments.map(a => a.employee_email).filter(Boolean))];
    
    const existingValue = employeeFilter.value;
    employeeFilter.innerHTML = '<option value="">All Employees</option>';
    
    employeeEmails.sort().forEach(email => {
        const user = allUsers.find(u => u.email === email);
        const option = document.createElement('option');
        option.value = email;
        option.textContent = user?.name || email;
        employeeFilter.appendChild(option);
    });
    
    if (existingValue) employeeFilter.value = existingValue;
}

function populateScorecardFilter() {
    const scorecardFilter = document.getElementById('scorecardFilter');
    if (!scorecardFilter) return;
    
    const existingValue = scorecardFilter.value;
    scorecardFilter.innerHTML = '<option value="">All Scorecards</option>';
    
    allScorecards.forEach(scorecard => {
        const option = document.createElement('option');
        option.value = scorecard.id;
        option.textContent = scorecard.name;
        scorecardFilter.appendChild(option);
    });
    
    if (existingValue) scorecardFilter.value = existingValue;
}

async function applyFilters() {
    // Get filter values
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    currentFilters.status = statusEl ? statusEl.value : '';
    currentFilters.channel = channelEl ? channelEl.value : '';
    currentFilters.auditor = auditorEl ? auditorEl.value : '';
    currentFilters.employee = employeeEl ? employeeEl.value : '';
    currentFilters.scorecard = scorecardEl ? scorecardEl.value : '';
    
    // Start with unfiltered assignments
    allAssignments = [...unfilteredAssignments];
    
    // Apply status filter
    if (currentFilters.status) {
        allAssignments = allAssignments.filter(a => a.status === currentFilters.status);
    }
    
    // Apply channel filter (need to look up employee's channel)
    if (currentFilters.channel) {
        allAssignments = allAssignments.filter(a => {
            const emp = allUsers.find(u => u.email === a.employee_email);
            return emp && emp.channel === currentFilters.channel;
        });
    }
    
    // Apply auditor filter
    if (currentFilters.auditor) {
        allAssignments = allAssignments.filter(a => a.auditor_email === currentFilters.auditor);
    }
    
    // Apply employee filter
    if (currentFilters.employee) {
        allAssignments = allAssignments.filter(a => a.employee_email === currentFilters.employee);
    }
    
    // Apply scorecard filter
    if (currentFilters.scorecard) {
        allAssignments = allAssignments.filter(a => a.scorecard_id === currentFilters.scorecard);
    }
    
    // Apply week/date range filter (from week navigation or date range picker)
    if (useWeekFilter && currentWeek !== null) {
        // Filter by week
        const weekDates = getWeekDates(currentWeek, currentWeekYear);
        allAssignments = allAssignments.filter(a => {
            if (!a.created_at) return false;
            return isDateInRange(a.created_at, weekDates.start, weekDates.end);
        });
    } else if (dateFilter.start || dateFilter.end) {
        // Filter by date range
        allAssignments = allAssignments.filter(a => {
            if (!a.created_at) return false;
            return isDateInRange(a.created_at, dateFilter.start, dateFilter.end);
        });
    }
    
    console.log(`Filtered to ${allAssignments.length} assignments`);
    
    // Update the dashboard with filtered data
    await updateDashboard();
}

async function clearFilters() {
    // Reset filter inputs
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    if (statusEl) statusEl.value = '';
    if (channelEl) channelEl.value = '';
    if (auditorEl) auditorEl.value = '';
    if (employeeEl) employeeEl.value = '';
    if (scorecardEl) scorecardEl.value = '';
    
    // Reset filter state
    currentFilters = {
        status: '',
        channel: '',
        auditor: '',
        employee: '',
        scorecard: ''
    };
    
    // Restore unfiltered data
    allAssignments = [...unfilteredAssignments];
    
    // Update the dashboard
    await updateDashboard();
}

// ============================================================================
// Week and Date Filter Functions
// ============================================================================
function getWeekNumber(date = new Date()) {
    const startOfYear = new Date(date.getFullYear(), 0, 1);
    const dayOfWeek = startOfYear.getDay();
    const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const mondayOfWeek1 = new Date(startOfYear);
    mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
    mondayOfWeek1.setHours(0, 0, 0, 0);
    
    const dateDay = date.getDay();
    const dateDaysToMonday = dateDay === 0 ? -6 : 1 - dateDay;
    const mondayOfDateWeek = new Date(date);
    mondayOfDateWeek.setDate(date.getDate() + dateDaysToMonday);
    mondayOfDateWeek.setHours(0, 0, 0, 0);
    
    const daysSinceWeek1 = Math.floor((mondayOfDateWeek - mondayOfWeek1) / (24 * 60 * 60 * 1000));
    const weekNumber = Math.floor(daysSinceWeek1 / 7) + 1;
    
    return weekNumber;
}

function getWeekDates(weekNumber, year) {
    const startOfYear = new Date(year, 0, 1);
    const dayOfWeek = startOfYear.getDay();
    const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const mondayOfWeek1 = new Date(startOfYear);
    mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
    
    const weekStart = new Date(mondayOfWeek1);
    weekStart.setDate(mondayOfWeek1.getDate() + (weekNumber - 1) * 7);
    weekStart.setHours(0, 0, 0, 0);
    
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    
    return { start: weekStart, end: weekEnd };
}

function initializeWeekFilter() {
    const today = new Date();
    currentWeek = getWeekNumber(today);
    currentWeekYear = today.getFullYear();
    updateWeekDisplay();
}

function updateWeekDisplay() {
    const weekTextEl = document.getElementById('weekText');
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    if (weekTextEl) {
        if (useWeekFilter && currentWeek !== null) {
            weekTextEl.textContent = `Week ${currentWeek}`;
        } else {
            weekTextEl.textContent = '-';
        }
    }
    
    // Disable/enable week navigation buttons based on date range filter
    if (prevWeekBtn) {
        if (useWeekFilter) {
            prevWeekBtn.disabled = false;
            prevWeekBtn.style.opacity = '1';
            prevWeekBtn.style.cursor = 'pointer';
        } else {
            prevWeekBtn.disabled = true;
            prevWeekBtn.style.opacity = '0.5';
            prevWeekBtn.style.cursor = 'not-allowed';
        }
    }
    
    if (nextWeekBtn) {
        if (useWeekFilter) {
            nextWeekBtn.disabled = false;
            nextWeekBtn.style.opacity = '1';
            nextWeekBtn.style.cursor = 'pointer';
        } else {
            nextWeekBtn.disabled = true;
            nextWeekBtn.style.opacity = '0.5';
            nextWeekBtn.style.cursor = 'not-allowed';
        }
    }
    
    // Update week display styling
    if (weekDisplay) {
        if (useWeekFilter) {
            weekDisplay.style.backgroundColor = 'var(--primary-color)';
            weekDisplay.style.color = 'var(--white)';
            weekDisplay.style.borderColor = 'var(--primary-color)';
        } else {
            weekDisplay.style.backgroundColor = '#f3f4f6';
            weekDisplay.style.color = '#6b7280';
            weekDisplay.style.borderColor = '#e5e7eb';
        }
    }
}

function navigateWeek(direction) {
    currentWeek += direction;
    
    if (currentWeek > 52) {
        currentWeek = 1;
        currentWeekYear += 1;
    } else if (currentWeek < 1) {
        currentWeek = 52;
        currentWeekYear -= 1;
    }
    
    updateWeekDisplay();
    useWeekFilter = true;
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    applyFilters();
}

function setupEventListeners() {
    // Week navigation buttons
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    if (prevWeekBtn) {
        prevWeekBtn.addEventListener('click', () => navigateWeek(-1));
    }
    if (nextWeekBtn) {
        nextWeekBtn.addEventListener('click', () => navigateWeek(1));
    }

    // Date button
    const dateBtn = document.getElementById('dateBtn');
    if (dateBtn) {
        dateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('dateDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        });
    }

    // Filter button
    const filterBtn = document.getElementById('filterBtn');
    if (filterBtn) {
        filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFilters();
        });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.date-picker-dropdown')) {
            const dateDropdown = document.getElementById('dateDropdown');
            if (dateDropdown) {
                dateDropdown.classList.remove('active');
            }
        }
        if (!e.target.closest('.filter-dropdown')) {
            const filterDropdown = document.getElementById('filterDropdown');
            const filterBtn = document.getElementById('filterBtn');
            if (filterDropdown) {
                filterDropdown.classList.remove('active');
            }
            if (filterBtn) {
                filterBtn.classList.remove('active');
            }
        }
    });
}

window.applyDateFilter = function() {
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const startDate = startDateEl?.value || '';
    const endDate = endDateEl?.value || '';
    
    if (startDate) {
        const start = new Date(startDate);
        start.setHours(0, 0, 0, 0);
        dateFilter.start = start;
    } else {
        dateFilter.start = null;
    }
    
    if (endDate) {
        const end = new Date(endDate);
        end.setHours(23, 59, 59, 999);
        dateFilter.end = end;
    } else {
        dateFilter.end = null;
    }

    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDate || endDate) {
        const start = startDate ? new Date(startDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'Start';
        const end = endDate ? new Date(endDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'End';
        if (dateBtnTextEl) dateBtnTextEl.textContent = `${start} - ${end}`;
        useWeekFilter = false;
        updateWeekDisplay(); // Update week display to show "-"
    } else {
        if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
        useWeekFilter = true;
        updateWeekDisplay(); // Update week display to show week number
    }

    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    applyFilters();
};

window.clearDateFilter = function() {
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    const dateDropdown = document.getElementById('dateDropdown');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    if (dateDropdown) dateDropdown.classList.remove('active');
    useWeekFilter = true;
    updateWeekDisplay(); // Update week display to show week number
    applyFilters();
};

// Helper function to normalize passing status (handles both old and new values)
// Matching expert-audits.html implementation
function normalizePassingStatus(status) {
    if (!status) return status;
    
    // Convert to string and trim
    const statusStr = String(status).trim();
    
    // Convert old values to new ones for consistency
    // Handle "Passing", "Pass", "passed" (case-insensitive)
    if (statusStr === 'Passing' || statusStr === 'Pass' || statusStr.toLowerCase() === 'passed') {
        return 'Passed';
    }
    // Handle "Not Passing", "Not Pass", "not passed" (case-insensitive)
    if (statusStr === 'Not Passing' || statusStr === 'Not Pass' || statusStr.toLowerCase() === 'not passed') {
        return 'Not Passed';
    }
    
    // Return as-is if already normalized or unknown
    return statusStr;
}

// Helper function to check if date is within filter range
function isDateInRange(date, filterStart, filterEnd) {
    if (!filterStart && !filterEnd) {
        // If no date filter, check against current week
        if (useWeekFilter && currentWeek !== null) {
            const weekDates = getWeekDates(currentWeek, currentWeekYear);
            filterStart = weekDates.start;
            filterEnd = weekDates.end;
        } else {
            return true; // No filters, show all
        }
    }
    
    if (!filterStart && !filterEnd) return true;
    const checkDate = new Date(date);
    checkDate.setHours(0, 0, 0, 0);
    
    if (filterStart) {
        const start = new Date(filterStart);
        start.setHours(0, 0, 0, 0);
        if (checkDate < start) return false;
    }
    
    if (filterEnd) {
        const end = new Date(filterEnd);
        end.setHours(23, 59, 59, 999);
        if (checkDate > end) return false;
    }
    
    return true;
}

// ============================================================================
// Realtime Presence Functions
// ============================================================================
async function setupPresenceTracking() {
    try {
        if (!window.supabaseClient || !currentUserEmail) {
            console.warn('Cannot setup presence: Supabase or user email not available');
            return;
        }

        // Get user info to check role
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        // Create a channel for auditor presence
        const channelName = 'auditor-presence';
        presenceChannel = window.supabaseClient.channel(channelName, {
            config: {
                presence: {
                    key: currentUserEmail, // Use email as presence key
                }
            }
        });

        // Track current user's presence
        presenceChannel
            .on('presence', { event: 'sync' }, () => {
                updateOnlineAuditors();
            })
            .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                console.log('User joined:', key, newPresences);
                updateOnlineAuditors();
            })
            .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                console.log('User left:', key, leftPresences);
                updateOnlineAuditors();
            })
            .subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    // Track current user as online
                    await trackPresence();
                    
                    // Set up heartbeat to keep presence alive
                    startHeartbeat();
                }
            });
    } catch (error) {
        console.error('Error setting up presence tracking:', error);
    }
}

async function trackPresence() {
    try {
        if (!presenceChannel) return;

        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        await presenceChannel.track({
            email: currentUserEmail,
            name: userInfo.name || currentUserEmail,
            role: userRole,
            online_at: new Date().toISOString(),
            page: 'auditor-dashboard'
        });
    } catch (error) {
        console.error('Error tracking presence:', error);
    }
}

function startHeartbeat() {
    // Clear any existing heartbeat
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
    }

    // Send heartbeat every 30 seconds to keep presence alive
    heartbeatInterval = setInterval(async () => {
        await trackPresence();
    }, 30000); // 30 seconds
}

function stopHeartbeat() {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
    }
}

function updateOnlineAuditors() {
    try {
        if (!presenceChannel) return;

        const state = presenceChannel.presenceState();
        const newOnlineAuditors = new Set();

        // Extract online auditor emails from presence state
        Object.values(state).forEach((presences) => {
            presences.forEach((presence) => {
                if (presence.role === 'Quality Analyst' && presence.email) {
                    newOnlineAuditors.add(presence.email);
                }
            });
        });

        onlineAuditors = newOnlineAuditors;
        
        // Update the UI to reflect online status
        updateOnlineStatusIndicators();
    } catch (error) {
        console.error('Error updating online auditors:', error);
    }
}

function updateOnlineStatusIndicators() {
    // Update status indicators in the table
    const tableBody = document.getElementById('performanceTableBody');
    if (!tableBody) return;

    // Find all rows and update their online status
    const rows = tableBody.querySelectorAll('div[data-auditor-email]');
    rows.forEach(row => {
        const auditorEmail = row.dataset.auditorEmail;
        const nameCell = row.querySelector('[data-label="Name"]');
        
        if (nameCell && auditorEmail) {
            if (onlineAuditors.has(auditorEmail)) {
                // Add or update online indicator
                let indicator = nameCell.querySelector('.online-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'online-indicator';
                    indicator.style.cssText = 'display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);';
                    indicator.title = 'Online';
                    nameCell.appendChild(indicator);
                }
            } else {
                // Remove online indicator
                const indicator = nameCell.querySelector('.online-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }
    });
}

async function cleanupPresence() {
    try {
        stopHeartbeat();
        
        if (presenceChannel) {
            await presenceChannel.untrack();
            await presenceChannel.unsubscribe();
            presenceChannel = null;
        }
    } catch (error) {
        console.error('Error cleaning up presence:', error);
    }
}

// ============================================================================
// Utility Functions
// ============================================================================
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// Cleanup on page unload
// ============================================================================
window.addEventListener('beforeunload', async () => {
    await cleanupPresence();
});
</script>


</body>
</html>

